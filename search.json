[{"title":"关于Nacos注册中心","url":"/2025/10/05/关于Nacos注册中心/","tags":["java","微服务架构"],"categories":["微服务"]},{"title":"docker基本使用与进阶","url":"/2025/08/15/docker基本使用与进阶/","content":"\n# docker基本使用与进阶\n\n## 一.前言\n\n在笔者大一学习开发知识的这段时间里，数据库、服务器等基本都是用docker进行容器化部署。随着需要部署的服务越来越多，笔者越发体会到docker的便利与强大（~~味大，无需多盐~~），感觉学习docker是很有必要的，于是特撰写此博文来对没有使用过docker的小白进行扫盲，并对docker的功能及命令进行汇总以便后期回顾，让小白快速掌握docker的基本用法。\n\n## 二.docker简介\n\n> 摘自百度百科：Docker是一组平台即服务（PaaS）的产品。它基于操作系统层级的虚拟化技术，将软件与其依赖项打包为容器。托管容器的软件称为Docker引擎。Docker能够帮助开发者在轻量级容器中自动部署应用程序，并使得不同容器中的应用程序彼此隔离，高效工作。\n\n通俗来讲，docker是一种成熟的软件部署技术，轻量高效，启动速度快。docker实际上就是将进程和它运行所需要的运行环境打包到一个容器里面，系统给其分配独立的文件系统、进程组和网络资源，并且容器与容器之间<u>互不干扰</u>（大部分如此，其他情况后面会给说明）。使用docker，部署服务将变得更加便捷高效，使你的开发效率得到大幅提升。\n\n## 三.docker安装\n\ndocker是基于Linux操作系统运作的，可以使用虚拟机或云服务器，或在windows系统上装一个WSL来安装使用\n\nWSL官方文档：[安装 WSL | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install?MSPPError=-2147217396)\n\ndocker安装：\n\n在Linux命令行中运行以下命令安装：\n\n```shell\ncurl -fsSL http://get.docker.com -o install-docker.sh\n```\n\n```shell\nsudo sh install-docker.sh\n```\n\n## 四.docker核心逻辑\n\n**docker镜像&docker容器：**docker镜像就相当于模板，而docker容器就是利用模板来制作的实例，一个镜像可以对应多个容器，你可以对容器添加各种参数或者直接修改容器内置配置文件来实现对容器的定制化\n\n## 五.常用命令\n\n接下来我将使用mysql作为例子\n\n### 1.对镜像操作\n\n#### docker pull\n\n这个命令就是让你从Docker Hub官方仓库拉取一个镜像\n\nDocker Hub官网：[Docker Hub Container Image Library | App Containerization](https://hub.docker.com/)\n\n```shell\ndocker pull docker.io/library/mysql:latest\n```\n\n这行命令代表我要从官方仓库拉取一个最新版本的mysql镜像\n\n**docker.io:**仓库地址registry(Docker Hub就是一个registry)，docker.io是Docker Hub的官方仓库，可以省略\n\n**library:**命名空间namespace（作者名），library是官方的命名空间，可以省略\n\n**latest:**标签tag（版本号），如果要获取最新版本镜像，可以省略\n\n仓库地址+命名空间+镜像名=repository(镜像库)，一个镜像库中存放了同一个镜像的不同版本\n\n如果拉取镜像时报错，有两个最常见的问题：\n\n**无权限**——此时需要你在每行命令前面加一个sudo来获取权限执行\n\n**网络问题**——需要配置国内镜像站，具体可从网上搜索做法\n\n```shell\ndocker pull --platform=xxxxxx mysql\n```\n\n这行命令中platform参数表示拉取特定CPU架构的镜像\n\n#### docker images\n\n```shell\ndocker images\n```\n\n这行命令是让终端列出所有下载过的docker镜像\n\n#### docker rmi\n\n```shell\ndocker rmi\n```\n\nrmi(remove image)表示删除镜像，后面可以加镜像名或镜像id进行删除\n\n### 2.对容器操作\n\n#### docker run\n\n```shell\ndocker run -d \\\n-p 3306:3306 \\\n-v /root/mysql/conf:/etc/mysql/conf.d \\\n-e username=root \\\n-e password=123456 \\\n--name my-mysql \\\nmysql\n```\n\n使用镜像创建并运行容器\n\n**--name:自定义容器名称**\n\n**-d:分离模式**，表示让容器在后台执行，容器启动以后日志不会打印到控制台\n\n**-p:端口映射**\n\n每一个容器都运行在一个独立的虚拟环境中，容器内的网络与宿主机的网络是隔离的，所以默认情况下不能从宿主机中访问到容器内的网络，比如我启动mysql容器但并没有做端口映射，在navicat中输入localhost，端口写3306并不能连接到mysql数据库。但如果我加上-p 3306:3306参数，表明将宿主机的3306端口(冒号前)转发到容器内的3306端口(冒号后)，这样访问宿主机3306端口也就相当于访问容器3306端口\n\n![示意图](D:\\itJinYu_toolkit\\web\\blog\\source\\assets\\post_img\\docker\\1.png)\n\n**-v:挂载卷**\n\n-v 宿主机目录:容器内目录(**绑定挂载**)，表示把宿主机与容器的文件目录进行绑定，两个文件夹修改是会互相影响的，这种目录被称为挂载卷。挂载卷可以实现数据的持久化保存，当我们删除容器以后，容器内的数据会一并删除，而当把容器内的数据挂载到宿主机上再删除容器，容器的数据还保存在宿主机上没被删除。\n\n> 这里有个细节，绑定挂载以后，宿主机的目录会暂时覆盖容器内的目录，也就是说现在容器内目录是空的，为此，我们可以直接修改宿主机目录(比如在宿主机加一个index.html文件来覆盖掉容器内目录的index.html文件)来使宿主机目录非空\n\n-v 卷的名字:容器内目录(**命名卷挂载**)\n\n```shell\ndocker volume create conf # 挂载卷的名字\n```\n\n此命令的作用为创建挂载卷，此时可以直接使用 conf:/etc/mysql/conf.d 来进行挂载\n\n```shell\ndocker volume inspect conf\n```\n\n执行这行命令可以显示这个挂载卷的信息，从这也可以看到这个挂载卷的真实目录，但进入这个目录需要切换到root用户：\n\n```shell\nsudo -i\n```\n\n这种挂载方式docker会把容器的文件夹同步到命名卷里面进行初始化，这样就避免了目录为空的情况\n\n**-e:环境变量**\n\n这里是将数据库的账号密码作为环境变量传递进去\n\n**--name:自定义容器名称**\n\n与容器ID等价，更加容易记忆\n\n**----------这里还有其他一些参数----------**\n\n**-it:可以让控制台进入容器进行交互**\n\n**--rm:当容器停止时就把容器删除**\n\n**--restart always:只要容器停止了就会立即重启**\n\n**--restart unless-stopped:唯一区别就是手动停止的容器不会重启**\n\n#### docker ps\n\n```shell\ndocker ps -a\n```\n\n查看当前正在运行的容器的信息，包括容器ID，镜像名称，容器名称等\n\n**-a:查看所有容器**\n\n#### docker stop\n\n```shell\ndocker stop my-mysql\n```\n\n停止my-mysql容器运行\n\n#### docker start\n\n```shell\ndocker start my-mysql\n```\n\n启动my-mysql容器\n\n#### docker rm\n\n```shell\ndocker rm -f my-mysql\n```\n\n删除my-mysql容器\n\n**-f:强制删除正在运行的容器**\n\n#### docker inspect\n\n```shell\ndocker inspect my-mysql # 或者容器ID\n```\n\n这里可以在控制台打印容器的详细信息，包括有没有做挂载卷，有没有做端口映射\n\n#### docker create\n\n```shell\ndocker create -p 3306:3306 mysql\n```\n\ndocker create和docker run命令的区别在于docker create只创建容器，但不启动容器\n\n#### docker logs\n\n```shell\ndocker logs -f my-mysql # 或者容器ID\n```\n\n这个命令可以查看容器日志\n\n**-f:表示滚动查看日志**\n\n#### docker exec\n\n```shell\ndocker exec -it my-mysql /bin/sh\n```\n\nexec可以在容器内部执行Linux命令\n\n这行命令可以进入一个正在运行的容器内部，获得一个交互式的命令行环境，容器内部就像是一个独立的Linux操作系统\n\n## 六.docker技术原理\n\ndocker利用linux的**Cgroups**和**Namespaces**进行容器化\n\n**Cgroups**来限制和隔离进程的资源使用，可以为容器进程设置内存、CPU、网络带宽等资源的使用上限，确保容器的资源消耗不会影响到宿主机和其他容器\n\n**Namespaces**用来隔离进程的资源视图，它使容器只能看到自己内部的进程ID、文件目录和网络资源\n\n> 容器本质上是一个特殊的进程，但容器内部更像是一个独立的操作系统，每个docker容器都是一个独立的运行环境\n\n## 七.Dockerfile\n\nDockerfile是一个详细列出镜像是如何制作的一个文件，我们可以使用Dockerfile制作镜像并把它推送到Docker Hub上去\n\n首先在要打包成镜像的同级目录创建一个Dockerfile文件(**注意，没有后缀**)\n\n我会用python程序打包来示例\n\n```dockerfile\nFROM python:3.13-slim # 表示这个镜像是从哪个镜像的基础上构建而来\n\nWORKDIR /app # 切换到镜像内的一个目录作为工作目录\n\nCOPY . . # 把代码文件拷贝到镜像内的工作目录，第一个点是这台电脑的当前目录，第二个点是镜像内的当前目录（/app）\n\nRUN pip install -r rm.txt # 在镜像执行安装命令\n\nEXPOSE 1000 # 声明镜像提供服务的端口，起提示作用，可不写\n\nCMD [\"python3\", \"main.py\"] # 每当容器启动，容器内就会执行这个命令\n```\n\nDockerfile准备好以后就可以开始构建镜像\n\n在命令行运行以下命令\n\n```shell\ndocker build -t 镜像名:版本号 . # 版本号可省略， . 表示在当前文件夹构建\n```\n\n然后再Docker Hub上登陆\n\n运行\n\n```shell\ndocker build -t 用户名/镜像名 .\n```\n\n```shell\ndocker push 用户名/镜像名/\n```\n\n## 八.docker网络\n\n### 1.桥接模式\n\n**桥接模式(Bridge)**，所有容器默认连接到这个网络，每个容器都分配一个内部IP地址，一般是172.17开头，在这个内部子网里面，容器与容器之间通过内部IP地址互相访问，但是容器与宿主机之间的网络是隔离的，这时候可以使用\n\n```shell\ndocker network create 子网名\n```\n\n创建子网，然后可以使容器加入不同子网，同一子网的容器可以互相使用名字或IP进行通信(这就是博文开头所说的其他情况)，但跨子网不能通信\n\n```shell\ndocker run --network 子网名\n```\n\n**--network:指定加入的子网**\n\n处在同一子网下的两个容器，a容器没做端口映射，但b容器做了端口映射，此时宿主机网络可以与b容器通信，b容器知道a容器的名字(**docker子网有一个DNS机制，可以把名字转换为IP地址**)，也可以与它通信，所以宿主机便可以间接与a容器进行通信\n\n### 2.Host模式\n\n这种模式使Docker容器直接功响宿主机的网络，容器直接使用宿主机的IP地址，也就无需进行端口映射，容器内的服务直接运行在宿主机的端口上\n\n### 3.none模式\n\nnone模式也就是不联网\n\n```shell\ndocker network list\n```\n\n展示所有的Docker网络\n\n```shell\ndocker network rm 子网名\n```\n\n删除自定义的子网\n\n## 九.docker compose\n\n往往一个项目会涉及到前端、后端、数据库的许多模块，如果把它们一个个拉取镜像，一个个创建容器就显得十分麻烦，这时候docker compose就发挥了作用\n\ndocker compose(轻量级，适合单机)是docker使用yml文件管理多个容器，可以理解为把多个docker run命令封装到了一个docker compose文件中\n\n```shell\ndocker compose -f /test.yaml up -d\n```\n\n启动这个文件中定义的所有容器\n\n**-f:指定文件**\n\n如果docker-compose.yaml文件名改动(比如改成test.yaml)，可以使用-f参数来指定文件以防识别不出来\n\n-d是后台运行\n\n```shell\ndocker compose down\n```\n\n停止并删除容器\n\n```shell\ndocker compose stop\n```\n\n只停止不删除\n\n```shell\ndocker compose start\n```\n\n启动容器","tags":["开发工具"],"categories":["dev tools"]},{"title":"学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式","url":"/2025/06/17/学习笔记——从零开始速通汇编(一)：汇编程序语句结构&寻址方式/","content":"\n**导航**\n\n[✨学习笔记——从零开始速通汇编(一)：寄存器 | JinYu🐟](https://jinyuuu.top/posts/5.html)\n\n[🎉学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式 | JinYu🐟](https://jinyuuu.top/posts/6.html)\n\n[🎊学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统 | JinYu🐟](https://jinyuuu.top/posts/7.html)\n\n[🎃学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/8.html)\n\n[🎄学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/9.html)\n\n---\n\n# 学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式\n\n## 前言：\n\n> 在经过上一文章的学习之后，接下来我们将学习汇编程序语句结构框架和寻址方式，正式开始汇编程序的编写\n\n## 结构、框架、伪指令：\n\n### 汇编语言分段结构：\n\n宏汇编是微软推出的8086系统最流行的汇编语言版本，其他版本和它大同小异\n\n汇编语言源程序采用分段结构，将源程序的指令代码、数据变量、堆栈分别定义在不同的主存段中\n\n比较典型的源程序包含三个段：**代码段**、**数据段**、**堆栈段**\n\n一个源程序可包含的段数是不受限制的，但8086CPU只提供了4个段寄存器，所以在一个源程序中最多只能操作**4个段**\n\n### 汇编语言语句结构：\n\n**[名字项]  操作项  [操作数项]  [; 注释项]**\n\n其中，[  ]表示为可选项\n\n#### 分类\n\n通过作用分为三类：\n\n1. **伪指令语句**\n\n   伪指令语句用来说明程序运行的处理器平台，进行段定义、变量与常量定义、过程定义、宏定义以及源程序的开始与结束定义等\n\n   伪指令语句作用于汇编过程，用来指示汇编程序如何进行源程序汇编（**不是实现操作**）\n\n2. **指令语句**\n\n   指令语句包含一条汇编语言指令\n\n   程序的操作功能是由指令语句来实现的\n\n3. **宏指令语句**\n\n   宏指令是宏汇编语言允许程序员自定义的一种特殊形式的指令（类比C语言的函数）\n\n   宏指令语句用来描述宏指令的使用\n\n#### 组成\n\n1. **名字项**\n\n   名字项是一个符合特定规则的字符串，其最大长度不超过31个字符，组成名字项的字符定为：26个英文字母（不分大小写），数字符0-9，以及?,·'_,@,$等\n\n   > 数字不能作为名字项的第一个字符\n   >\n   > ·只能作为名字项第一个字符用\n\n2. **操作项**\n\n   操作项是一条语句中必不可少的部分\n\n3. **操作数项**（了解即可）\n\n   可以是一个、两个或没有，可以是常量、变量、寄存器、指令标号、过程名、段名或表达式\n\n### 常用伪指令：\n\n#### 段定义伪指令\n\n格式：\n\n```assembly\n段名 SEGMENT [定位类型] [组合类型] ['类别']\n\t\t\t......;段的具体内容\n段名 ENDS\n```\n\n**[定位类型]**：PARA(默认)、BYTE(任何)、WORD(段首地址必须为偶数)、DWORD(段首地址被4整除)、PAGE(段首地址被256整除)\n\n**[组合类型]**：\n\n**PUBLIC**：多个模块中具有该组合类型的同名，同类别连成一个段，总容量不能超过64KB\n\n**STACK**：同PUBLIC，但是堆栈段\n\n**COMMON**：段容量为组合段中的最大段\n\n**['类别']**：在任意一个合法的字符串，起到组合作用\n\n#### ASSUME伪指令\n\nASSUME是建立段寄存器与段之间联系的语句，是必不可少的，格式为：\n\n```assembly\nASSUME 段寄存器名:段名 [,段寄存器名:段名,[,...]]\n```\n\n#### 源程序结束伪指令格式\n\n```assembly\nEND [指令标号]\n```\n\n**标准堆栈段、数据段、代码段框架结构：**\n\n![框架结构](/assets/post_img/汇编语言/8.png)\n\n注意这块内容作用为结束程序运行，返回操作系统命令状态(类比C语言return 0)\n\n```assembly\nMOV AH,4CH\nINT 21H\n```\n\n这里END后面没有带S，因为是源程序结束，段程序结束才有S\n\n```assembly\nEND START\n```\n\n### 变量定义与存储空间分配：\n\n**DB-定义字节类型**   例：VAR1 DB 46H\n\n**DW-定义字类型**   例：VAR2 DW 2A05H\n\n**DD-定义双字类型**   例：VAR3 DB 26*3,-53,00101001B\n\n**DQ-定义四字类型**   例：VAR4 DW 12H,0A186H\n\n**DT-定义十字节类型**   例：VAR5 DB ?,?,?,?,?,?,?,?,?,?     |**但是有DUP操作符简化：重复次数 DUP (数据项)**\n\n### 属性运算符\n\nOFFSET:用于取变量或标号的段内偏移地址\n\n```assembly\nOFFSET 变量或标号\n```\n\nSEG:用于取变量或标号的段地址\n\n```assembly\nSEG 变量或标号\n```\n\nPTR:用于重新指定变量、标号或地址表达式的**访问类型**\n\n```assembly\n新类型 PTR 变量或标号或地址表达式\n```\n\n可重新定义的类型有：BYTE\\WORD\\DWORD\\NEAR(近类型)\\FAR(远类型)\n\n> 例：\n>\n> (1)OFFSET VAR1\n>\n> (2)OFFSET VAR2+1\n>\n> (3)SEG VAR3\n>\n> (4)WORD PTR VAR3\n\n### 替代符定义伪指令\n\n**EQU伪指令定义替代符**\n\n```assembly\n替代符 EQU 表达式\n```\n\n**=伪指令定义替代符**\n\n```assembly\n替代符 = 表达式\n```\n\n**※=伪指令定义替代符可在同一个源程序中重复定义**，有效范围是从被定义开始到下一次被定义\n\n**※替代符**与**变量**有本质的区别：变量需要分配存储空间，但替代符不会，它只是某个表达式的别名，汇编程序在对其进行汇编时，会用表达式的值置换\n\n**EQU**在程序中只能指定**一次**(类比C语言的const)，而**=**在程序中可以指定**多次**\n\n### 段内偏移地址指针设置伪指令\n\n段内偏移地址$\n\n段内偏移地址指针设置伪指令ORG\n\n```assembly\nDSEG SEFMENT\nDATE1 DB 14H DUP(?)\nORG 100H\nDATE2 DW 1375H,2468H\nDSEG ENDS\n```\n\n> 说明：ORG使指针在段内偏移100H，所以1357H不是从段首开始存储，而是从段首偏移100H的地方开始存储\n\n{% note warning flat %}存储的时候采用的是小端存储，存的时候整体往下存储，但比如  VAR1 DW 3B04H  存储的时候是04H在上，3BH在下{% endnote %}\n\n## 寻址方式：\n\n**寻址方式**：指令指定操作数的位置，即给出地址信息，在执行时需要根据这个地址信息找到需要的操作数\n\n这种**寻找操作数的过程**称为寻址，而**寻找操作数的方法**称为寻址方式\n\n**立即数**：指令中操作数字段实质上是指出操作数存放于何处，一般来说，操作数可以跟随在指令操作码之后，称为立即数\n\n**寄存器操作数**：操作数也可以存放在CPU内部的寄存器中\n\n**存储器操作数**：绝大多数的操作数存放在内存储器中\n\n### 寄存器寻址\n\n参加操作的操作数在CPU的**通用寄存器**中\n\n例：\n\n```assembly\nMOV AX,BX\n```\n\n\n\n> 对于8086，寄存器可以是AX,BX,CX,DX,SI,DI,SP,BP\n>\n> 也可以是AL,AH,BL,BH,CL,CH,DL,DH\n\n### 立即寻址\n\n指令中的源操作数是立即数，即源操作数是参加操作的数据本身\n\n例：\n\n```assembly\nMOV BX,2200H\n```\n\n\n\n### 存储器寻址\n\n**存储器寻址**：直接寻址、寄存器间接寻址、寄存器相对(+某数)寻址、基址变址寻址、相对基址变址寻址\n\n#### 直接寻址\n\n指令中直接给出操作数的偏移地址\n\n例：\n\n```assembly\nMOV AX,[1100H]  （默认在数据段中）\n```\n\n\n\n#### 寄存器间接寻址\n\n参与操作的操作数存放在内存中，其偏移地址伪指令中的寄存器的内容\n\n例：\n\n```assembly\n设BX=2400H,MOV AX,[BX]\n```\n\n16位寻址时可用的寄存器是BX,DI,SI和BP\n\n#### 寄存器相对地址\n\n操作数的有效地址为**基址寄存器**或**变址寄存器**的内容和指令中指定的位移量之和，有效地址由两种成分组成\n\n例：\n\n```assembly\nMOV AX,COUNT[SI]\n\nMOV AX,[COUNT+SI]\n```\n\n16位寻址时可用的寄存器是BX,DI,SI和BP\n\n#### 基址变址寻址\n\n操作数的有效地址是**一个基址寄存器和一个变址寄存器的内容之和**，所以有效地址由两种成分组成\n\n例：\n\n```assembly\nMOV AX,[BX][DI]\nMOV AX,[BX+DI]\n```\n\n基址寄存器是BX是，段寄存器默认DS；基址寄存器是BP时，段寄存器默认SS\n\n#### 相对基址变址寻址\n\n操作数的有效地址是**一个基址寄存器和一个变址寄存器的内容和指令中指定的位移量之和**，所以有效地址由三种成分组成\n\n例：\n\n```assembly\nMOV AX,D[BX][SI]\nMOV AX,D[BX+SI]\nMOV AX,[D+BX+SI]\n```\n\n基址寄存器是BX是，段寄存器默认DS；基址寄存器是BP时，段寄存器默认SS\n\n### 隐含寻址\n\n在8086指令系统中，有些指令默认操作数存放在某个特定的寄存器中，从而可省略对该操作数的描述，称为**隐含寻址**\n\n例：\n\n```assembly\nMUL BX\n```\n\n### 总结对照\n\n![总结](/assets/post_img/汇编语言/9.png)\n\n> 另外，还有**转移地址的寻址方式**\n>\n> 段内寻址\n>\n> - **段内直接寻址**   JMP NEAR PTR NEXT\n> - **段内间接寻址**   JMP TABLE[BX]\n>\n> 段间寻址\n>\n> - **段间直接寻址**   JMP FAR PTR NEXT\n> - **段间间接寻址**   JMP DWORD PTR [BX]","tags":["汇编"],"categories":["Assembly"]},{"title":"学习笔记——从零开始速通汇编(一)：寄存器","url":"/2025/06/17/学习笔记——从零开始速通汇编(一)：通用寄存器/","content":"\n**导航**\n\n[✨学习笔记——从零开始速通汇编(一)：寄存器 | JinYu🐟](https://jinyuuu.top/posts/5.html)\n\n[🎉学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式 | JinYu🐟](https://jinyuuu.top/posts/6.html)\n\n[🎊学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统 | JinYu🐟](https://jinyuuu.top/posts/7.html)\n\n[🎃学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/8.html)\n\n[🎄学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/9.html)\n\n---\n\n# 学习笔记——从零开始速通汇编(一)：寄存器\n\n## 前言：\n\n> 笔者所属的专业大一下新开了汇编语言课程，鉴于笔者对计算机的兴趣，特写此系列博客文来记录下汇编语言课程的学习过程及知识点，也可供读者进行学习或者在期末对照此文进行复习或速通\n\n![嘻嘻](/assets/post_img/汇编语言/1.jpg)\n\n------\n\n\n\n## 汇编语言简介：\n\n### 什么是汇编语言\n\n**汇编语言**（**Assembly Language**）是一种低级编程语言，它与计算机的机器语言指令几乎一一对应，但使用人类可读的助记符（**mnemonics**）代替二进制或十六进制操作码\n\n### 汇编语言的特点\n\n1. **接近硬件**：直接对应处理器指令集\n2. **高效性**：可以编写高度优化的代码\n3. **可读性**：比机器语言更易于理解和编写\n4. **平台相关**：不同CPU架构有不同的汇编语言\n\n### 汇编语言基本组成\n\n1. **指令**：对应CPU操作（如MOV, ADD, JMP等）\n2. **寄存器**：CPU内部的高速存储单元\n3. **内存地址**：数据存储位置\n4. **伪指令**：汇编器指令，不生成机器码\n\n## 知识回顾\n\n一个典型CPU是**由运算器**、**寄存器**和**控制器**等器件组成的，这些器件靠内部的总线相连\n\n**寄存器(Register)**：处理器内部用于**暂时存放**程序执行过程中的**数据和代码**的高速存储单元\n\n**程序可见寄存器**(作为速通，先不讨论程序不可见寄存器)分为**通用寄存器**和**专用寄存器(段寄存器)**\n\n## 寄存器\n\n {% note warning flat %}如果是速通，以下了解即可，不用背{% endnote %}\n\n### 通用寄存器 (General-Purpose Registers)\n\n#### x86架构 (32位) 通用寄存器\n\n1. **EAX** (累加器) - 用于算术运算和函数返回值\n2. **EBX** (基址寄存器) - 常用作内存访问的基址指针\n3. **ECX** (计数器) - 常用于循环计数\n4. **EDX** (数据寄存器) - 用于I/O操作和扩展EAX\n5. **ESI** (源索引) - 字符串/内存操作的源指针\n6. **EDI** (目的索引) - 字符串/内存操作的目标指针\n7. **ESP** (栈指针) - 指向栈顶\n8. **EBP** (基址指针) - 用于栈帧基址\n\n#### x86-64架构 (64位) 扩展的通用寄存器\n\n1. **RAX**, **RBX**, **RCX**, **RDX** (64位扩展)\n2. **R8** - **R15** (新增的8个64位通用寄存器)\n\n#### ARM架构通用寄存器\n\n1. **R0-R12** - 通用寄存器\n2. **R0-R3** - 常用于函数参数传递\n3. **R0** - 常用于函数返回值\n\n#### 专用寄存器 (Special-Purpose Registers)\n\n#### x86架构专用寄存器\n\n1. **EIP** (指令指针) - 存储下一条要执行的指令地址\n2. **EFLAGS** - 状态标志寄存器，包含各种状态位：\n   - CF (进位标志)\n   - ZF (零标志)\n   - SF (符号标志)\n   - OF (溢出标志)\n   - PF (奇偶标志)\n   - AF (辅助进位标志)\n3. **CR0-CR4** (控制寄存器) - 控制CPU操作模式\n4. **DR0-DR7** (调试寄存器) - 用于硬件调试\n5. **GDTR**, **LDTR**, **IDTR**, **TR** (系统表寄存器)\n\n#### x86-64架构新增专用寄存器\n\n1. **RFLAGS** - 64位标志寄存器\n2. **RIP** - 64位指令指针\n\n#### ARM架构专用寄存器\n\n1. **CPSR** (当前程序状态寄存器) - 类似x86的EFLAGS\n2. **SPSR** (保存的程序状态寄存器) - 异常模式下保存CPSR\n3. **PC** (程序计数器) - 类似x86的EIP/RIP\n4. **SP** (栈指针) - 类似x86的ESP/RSP\n5. **LR** (链接寄存器) - 存储返回地址\n\n## 通用寄存器\n\n### 常见通用寄存器\n\n处理器比较常见的就是**8086 CPU**\n\n> 一共有14种\n>\n> AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW\n\n其AX寄存器的逻辑结构如图所示：\n\n![寄存器逻辑结构](/assets/post_img/汇编语言/2.png)\n\n> 不光是AX，BX、CX、DX都是这种结构\n>\n> 注意：数据都是以二进制来存放\n\n一个16位寄存器可以存储一个16位的数据\n\n如十进制数18(二进制10010)，在寄存器AX中的存储为：\n\n![十进制数18](/assets/post_img/汇编语言/3.png)\n\n8086寄存器上一代是8位寄存器，所以为了保证原来编写的程序在8086寄存器能正常运行，将每个8086寄存器划分为两个可以独立使用的8位寄存器\n\n![高位低位寄存器](/assets/post_img/汇编语言/4.png)\n\n如图，0-7为AL(low，低位)，8-15为AH(high，高位)\n\n> 同理：\n>\n> BX->BH  BL\n>\n> CX->CH  CL\n>\n> DX->DH  DL\n\n出于对兼容性的考虑，8086CPU可以一次性处理字节数据和字数据\n\n> 这里提醒一下\n>\n> **字节(byte)**：一个字节由8个位( bit)组成，可以存在**8位寄存器**中\n>\n> **字(word)**：一个字由2个字节组成，两个字节分别称为这个字的**高位字节**和**低位字节**\n>\n> 其次还有其他类型\n>\n> **双字类型**：32位（4个字节），连续占用4个存储单元\n>\n> **四字类型**：64位（8个字节），连续占用8个存储单元\n>\n> **十字节类型**：80位（十个字节），连续占用10个存储单元\n\n#### 指令：\n\n##### 了解概念\n\n**汇编指令**是汇编语言的核心组成部分，它们直接对应处理器能够执行的低级操作\n\n##### 基本指令\n\n这里先介绍两个常用的指令：\n\nMOV  把某数送到某地\n\nADD  把某数加到某地\n\n![mov和add指令](/assets/post_img/汇编语言/5.png)\n\n了解了基本用法之后，可以看下面表格加深理解\n\n![mov和add指令](/assets/post_img/汇编语言/6.png)\n\n{% note warning flat %}注意：如果相加后数字超过四位，那么最高位舍去{% endnote %}\n\n### 其他寄存器和段\n\n#### BP\\SI\\DI\n\n这三者也是通用寄存器家族的成员，但它们与AX\\BX\\CX\\DX的本质区别在于**它们都是不能分解的16位寄存器，可以存放16位的数据**\n\n> 此外，BP可以生成一个存储器地址\n>\n> SI\\DI在某些指令中被指定使用\n\n#### SP\\IP\n\nSP和IP都是16位寄存器\n\n**区别：**\n\nSP:堆栈指针，存放的是堆栈栈顶指针，内容随着入栈出栈动态改变\n\nIP:指令指针，用来提供下一条执行的指令的地址\n\n#### FLAGS\n\nFLAGS寄存器为标志寄存器，表示CPU的一个状态\n\n**CF(Carry Flag):**\n\n**进位标志位**   加（减）法运算时，若最高位有进（借）位则CF=1；没有进位则CF=0\n\n**PF(Parity Flag):**\n\n**奇偶标志位**   运算结果的低8位中“1”的个数为偶数时PF=1；为奇数时PF=0\n\n**AF(Auxiliary Carry Flag):**\n\n**辅助进位标志位**   加（减） 操作中，若Bit3向Bit4进位（借位），AF=1；没有进位，AF=0\n\n> 这个要注意，bit是从0开始数的\n\n**ZF(Zero Flag):**\n\n**零标志位**   当运算结果为零时ZF=1；不为零时ZF=0\n\n**SF(Sign Flag):**\n\n**符号标志位**   当运算结果是负数时，SF=1；运算结果是正数时，SF=0\n\n**OF(Overflow Flag):**\n\n**溢出标志位**   当算术运算的结果超出了有符号数的可表达范围时，OF=1；未超出时，OF=0\n\n例：\n\n![条件标志状态分析](/assets/post_img/汇编语言/7.png)\n\n#### 段寄存器\n\n**存储器**的地址分为**段地址**和**偏移地址**\n\n**段寄存器**就是来存放**段地址**的\n\n**CS:**\n\n**代码段寄存器**   与指令指针构成CS:IP(段地址:偏移地址)，一般十六进制表示，实际逻辑地址（物理地址）表示公式：**段地址×16+偏移地址**\n\n**DS:**\n\n**数据段寄存器**\n\n**ES:**\n\n**附加段寄存器**\n\n**SS:**\n\n**堆栈段寄存器**   与堆栈指针构成SS:SP\n\n#### 段\n\n段的 划分来自**CPU**，在编程时可以根据需要将若干连续的内存单元看作一个段，用**段地址×16**定位段的**起始地址**，用**偏移地址**来定位段的**内存单元**\n\n**注意：**\n\n> - 一个段的起始地址必须是16的倍数\n> - 偏移地址为16位，寻址能力为64KB，即一个段的长度最大为64KB\n","tags":["汇编"],"categories":["Assembly"]},{"title":"学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统","url":"/2025/06/17/学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统/","content":"\n**导航**\n\n[✨学习笔记——从零开始速通汇编(一)：寄存器 | JinYu🐟](https://jinyuuu.top/posts/5.html)\n\n[🎉学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式 | JinYu🐟](https://jinyuuu.top/posts/6.html)\n\n[🎊学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统 | JinYu🐟](https://jinyuuu.top/posts/7.html)\n\n[🎃学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/8.html)\n\n[🎄学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/9.html)\n\n---\n\n# 学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统\n\n## 前言：\n\n> 正式进入指令系统学习\n\n## 数据传送类指令：\n\n**数据传送类指令**用于在寄存器之间、寄存器与存储单元之间或CPU与I/O端口之间传送信息，传送的信息位数据或地址\n\n### MOV指令\n\n指令格式：MOV DST,SRC\n\n指令功能：**MOV指令**是最常用的数据传送指令，其传送对象可以是**数据**，也可以是**地址**\n\n> 注意：\n>\n> - DST和SRC数据类型必须保持一致\n> - SRC可以使用寄存器立即寻址和各种存储器寻址方式，DST只能采用寄存器寻址和各种存储器寻址方式\n> - DST和SRC不能同时采用存储器寻址\n> - DST不能是CS\n> - 当DST为段寄存器时（除CS），SRC不能为立即数或段寄存器\n\n### XCHG指令\n\n指令格式：XCHG OPR1,OPR2\n\n指令功能：将操作数**OPR1**和**OPR2**的内容互换\n\n> 注意：\n>\n> - 数据类型一致\n> - XCHG只能在通用寄存器之间或通用寄存器和存储单元之间进行交换\n> - 不能采用立即寻址\n\n### LEA指令\n\n指令格式：LEA DST,SRC\n\n指令功能：DST←SRC的偏移位置\n\n> 注意：\n>\n> - SRC必须是存储器寻址\n> - DST必须是除段寄存器外的16位寄存器\n\n{% note warning flat %}LEA SI,[BX+6]与MOV SI,OFFSET[BX+6]不能等效，因为OFFSET是运用于汇编过程的，而在汇编中，[BX+6]的值是未知的{% endnote %}\n\n### XLAT指令(查表指令)\n\n指令格式：XLAT\n\n指令功能：AL←((BX)+(AX))\n\n### PUSH和POP指令\n\nPUSH和POP分别是堆栈的**进栈**和**出栈**操作指令\n\n堆栈区的**高地址端**称为**栈底**，**低地址端**称为**栈顶**\n\n汇编语言程序中所用的堆栈由**堆栈段**定义，**堆栈段寄存器**为**SS**，**堆栈指针**为**16位寄存器SP**，数据进栈与出栈均以字为单位进行\n\n#### PUSH指令\n\n指令格式：PUSH OPR\n\n指令功能：将**字类型**操作数OPR存入堆栈\n\nPUSH指令的操作可表示为以下两步：\n\nSP←(SP)-2\n\n(SP)←OPR\n\n> 注意：\n>\n> - OPR不能用立即数寻址\n> - OPR一定是字类型\n\n#### POP指令\n\n指令格式：POP OPR\n\n指令功能：将栈顶元素去除并存入**字类型**操作数OPR\n\nPOP指令的操作可表示为以下两步：\n\nOPR←((SP))\n\nSP←(SP)+2\n\n> 注意：\n>\n> - OPR不能用立即数寻址\n> - OPR一定是字类型\n> - OPR不能是代码段寄存器CS\n\n### IN指令\n\n指令格式：\n\n1. IN AL,PORT   **直接寻址**方式，PORT为端口地址\n2. IN AL,DX   **间接寻址**方式，DX的内容为端口地址\n3. IN AX,PORT   **直接寻址**方式，PORT为端口地址\n4. IN AX,DX   **间接寻址**方式，DX的内容为端口地址\n\n指令功能：输入指令，其功能是将I/O端口的数据传送到AL或AX寄存器\n\n例：要从61H端口输入数据\n\nIN AL,61H\n\n例：要从61H和62H两个端口输入数据\n\nIN AX,61H\n\n例：要从300H端口输入数据\n\nMOV DX,300H\n\nIN AL,DX\n\n### OUT指令\n\n与IN指令相反\n\n## 算术运算类指令：\n\n### 加法类指令\n\n#### ADD指令\n\n指令格式：ADD DST,SRC\n\n指令功能：DST←(DST)+(SRC)\n\n> 注意：\n>\n> - 类型一致\n> - DST和SRC不能同时采用存储器的存储方式\n> - DST和SRC均不能为段寄存器\n\n#### ADC指令\n\n指令格式：ADC DST,SRC\n\n指令功能：DST←(DST)+(SRC)+CF\n\nADC指令为**带进位加法**的指令，即在普通加法的基础上再加上此前的指令所产生的CF标志值\n\n该指令主要用于**多字节数相加**\n\n> 注意：\n>\n> - 类型一致\n> - DST和SRC不能同时采用存储器的存储方式\n> - DST和SRC均不能为端寄存器\n\n#### INC指令\n\n指令格式：INC OPR\n\n指令功能：OPR←(OPR)+1\n\nINC指令也称**加1指令**，常用于**计数**和**修改地址指针**\n\n> 注意：\n>\n> - OPR不能为立即数或者段寄存器\n> - OPR必须有明确的数据类型\n> - 不影响CF\n\n### 减法类指令\n\n#### SUB指令\n\n指令格式：SUB DST,SRC\n\n指令功能：DST←(DST)-(SRC)\n\nSUB指令执行**常规减法**运算，其在使用上的要求与ADD指令完全相同\n\n#### SBB指令\n\n指令格式：SBB DST,SRC\n\n指令功能：DST←(DST)-(SRC)-CF\n\nSBB指令为**带借位减法**指令，即在普通减法的基础上再减去此前的指令所产生的CF标志值\n\n该指令主要用于**多字节数相减**\n\n#### DEC指令\n\n指令格式：DEC OPR\n\n指令功能：OPR←(OPR)-1\n\nDEC指令也称**减1指令**，常用于**计数**和**修改地址指针**\n\nDEC指令在使用上的要求与INC指令完全相同\n\n相对于INC指令的顺计数，**DEC指令**的**倒计数**在汇编语言设计中用的更多(如**循环计数**)\n\n#### CMP指令\n\n指令格式：CMP DST,SRC\n\n指令功能：(DST)-(SRC)\n\nCMP指令称为**比较指令**，CMP指令执行一次减法运算，**影响全部状态标志**，但**不保存运算结果**\n\nCMP指令在使用上的要求与SUB指令完全相同\n\nCMP时比较指令，但其本身并不能完成这种比较，它只是通过设置各种条件标志为实际的比较提供条件（实际的比较由专门的指令完成）\n\n#### NEG指令\n\n指令格式：NEG OPR\n\n指令功能：OPR←0-(OPR)\n\nNEG指令也称**求补指令**，用于求**有符号数**（以补码表示）的**相反数**，各状态标志按0-(OPR)运算来设置\n\nOPR不能为立即数或段寄存器，且必须有明确的数据类型\n\n### 乘法类指令\n\n#### MUL指令\n\n指令格式：MUL SRC       SRC为**乘数**，被乘数隐含\n\n指令功能：MUL为**无符号数**乘法指令。当SRC为**字节类型**数据时，被乘数默认为**AL**，乘积存于AX；当SRC为**字类型**数据时，被乘数默认为**AX**，乘积存于**DX:AX**（即乘积的高16位存于DX，低16位存于AX）\n\n例：\n\nMUL BL;AX←(AL)×(BL)\n\nMUL CX;DX:AX←(AX)×(CX)\n\n> 注意：\n>\n> - SRC不能是立即数或段寄存器\n> - SRC必须有明确的数据类型\n> - MUL指令影响CF和OF\n\n#### IMUL指令\n\n指令格式：IMUL SRC       SRC为**乘数**，被乘数隐含\n\n指令功能：IMUL为**有符号数**乘法指令，其在用法上与MUL指令相同\n\n跟MUL类似\n\n### 除法类指令\n\n#### DIV指令\n\n指令格式：DIV SRC       SRC为**除数**，被除数隐含\n\n指令功能：DIV为**无符号数**乘法指令。当SRC为**字节类型**数据时，被除数默认为**AX**，商存于AL；当SRC为**字类型**数据时，被除数默认为**AX**，乘积存于**DX:AX**（即乘积的高16位存于AX，低16位存于DX）\n\n例：\n\nDIV BL;(AX)÷(BL)  商存于AL,余数存于AH\n\nDIV CX;(DX:AX)÷(CX)  商存于AX,余数存于DX\n\n> 注意：\n>\n> - SRC不能是立即数或段寄存器\n> - SRC必须有明确的数据类型\n> - 当商超出了表示范围会发生除法溢出\n\n#### IDIV指令\n\n指令格式：IDIV SRC;       SRC为**除数**，被除数隐含\n\n指令功能：IDIV为**有符号数**除法指令，其在用法上与DIV指令相同\n\n> 注意：\n>\n> - 对有符号数除法，余数的符号与被除数符号相同\n> - 其他与DIV相同\n\n### 符号扩展指令\n\n此类指令用于**有符号数**（补码）的**位数扩展**，以满足有符号数运算对数据位数的要求\n\n#### CBW指令\n\n指令格式：CBW;       隐含操作数为AL\n\n指令功能：将**AL**中的**有符号数**扩展到**AX**中（即将8位有符号数扩展为16位）。该指令实际上是将AL的**符号位**扩展到**AH**中，故称”符号扩展“\n\n#### CWD指令\n\n指令格式：CWD;       隐含操作数为AX\n\n指令功能：将**AX**中的**有符号数**扩展到**DX:AX**中（即将16位有符号数扩展为32位）。该指令实际上是将AX的**符号位**扩展到**DX**中，故称”符号扩展“","tags":["汇编"],"categories":["Assembly"]},{"title":"学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统","url":"/2025/06/17/学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统/","content":"\n**导航**\n\n[✨学习笔记——从零开始速通汇编(一)：寄存器 | JinYu🐟](https://jinyuuu.top/posts/5.html)\n\n[🎉学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式 | JinYu🐟](https://jinyuuu.top/posts/6.html)\n\n[🎊学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统 | JinYu🐟](https://jinyuuu.top/posts/7.html)\n\n[🎃学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/8.html)\n\n[🎄学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/9.html)\n\n---\n\n# 学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统\n\n## 逻辑运算与移位操作类指令\n\n### 逻辑运算类指令\n\n逻辑运算是**按位进行**的，位与位之间不存在任何关联\n\n#### AND指令（与ADD指令要求一致）\n\n指令格式：AND DST,SRC\n\n指令功能：DST←(DST)∧(SRC)\n\nADD指令是**逻辑”与“运算**指令\n\n#### OR指令\n\n指令格式：OR DST,SRC\n\n指令功能：DST←(DST)∨(SRC)\n\nOR指令是**逻辑”或“运算**指令\n\nOR指令在使用上的要求以及对条件标志的影响与AND指令完全相同\n\n#### XOR指令\n\n指令格式：XOR DST,SRC\n\n指令功能：DST←(DST)⊕(SRC)\n\nXOR指令是**逻辑”异或“运算**指令\n\nXOR指令在使用上的要求以及对条件标志的影响与AND指令完全相同\n\n#### NOT指令\n\n指令格式：NOT OPR\n\n指令功能：OPR←(OPR)\n\nNOT是**逻辑”非“运算**指令\n\n> 注意：\n>\n> - OPR不能为立即数或段寄存器\n> - OPR必须有明确的数据类型\n> - NOT指令不影响任何条件标志\n\n#### TEST指令\n\n指令格式：TEST DST,SRC\n\n指令功能：(DST)∧(SRC)\n\nTEST指令执行**逻辑”与“运算**，但不保存运算结果，只像AND指令那样**影响有关条件标志**\n\nTEST指令称为**测试指令**，主要用于测试数据中某位是0还是1\n\n### 移位操作类指令\n\n移位操作用于对一个数据的各位做**向左**或**向右**的**移动**\n\n移位操作可分为**逻辑移位**、**算数移位**和**循环移位**三类\n\n各类移位指令的格式如下：\n\n![移位指令及格式](/assets/post_img/汇编语言/10.png)\n\nDST是被移位操作数，SRC是移位的次数\n\n> 注意：\n>\n> - DST不能是立即数和段寄存器\n> - 必须有明确的类型\n> - 当CNT=1时可以直接写1，否则必须用CL表示移位次数\n\n其中，**DST**是被移位的操作数，**CNT**是移位的次数\n\n![示意图](/assets/post_img/汇编语言/11.png)\n\n","tags":["汇编"],"categories":["Assembly"]},{"title":"学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统","url":"/2025/06/17/学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统/","content":"\n**导航**\n\n[✨学习笔记——从零开始速通汇编(一)：寄存器 | JinYu🐟](https://jinyuuu.top/posts/5.html)\n\n[🎉学习笔记——从零开始速通汇编(二)：汇编程序语句结构&寻址方式 | JinYu🐟](https://jinyuuu.top/posts/6.html)\n\n[🎊学习笔记——从零开始速通汇编(三)：数据传送类&算术运算类指令系统 | JinYu🐟](https://jinyuuu.top/posts/7.html)\n\n[🎃学习笔记——从零开始速通汇编(四)：逻辑运算与移位操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/8.html)\n\n[🎄学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统 | JinYu🐟](https://jinyuuu.top/posts/9.html)\n\n---\n\n# 学习笔记——从零开始速通汇编(五)：程序控制类&串操作类指令系统\n\n## 程序控制类指令：\n\n**程序控制类**指令用于实现复杂的程序**执行路径控制**，包括分支、循环、子程序调用与返回、中断服务程序调用与返回等\n\n程序**转移执行**时，需要用**程序控制类指令**来**修改IP**(段内转移)或**CS:IP**(段间转移)，以达到改变程序执行路径的目的\n\n#### 无条件转移指令\n\n指令格式：JMP OPR\n\n指令功能：按**OPR**描述的**转移地址**，无条件转移到目标指令执行\n\n#### 条件转移指令\n\n**条件转移指令**在满足特定的条件时，转移到指定的目标指令处继续往下执行程序，而在条件不满足时，则顺序执行程序（不转移）\n\n条件转移指令所检测的条件有**单个条件**标志CF、ZF、SF、OF、PF，也有由多个条件标志形成的**组合条件**，如CF和ZF的组合，SF、OF及ZF的组合等\n\n条件转移指令通常在运算类指令之后使用\n\n条件转移指令均为**段内短距离转移**指令。转移成功时，将IP修改为目标指令的偏移地址，而转移失败时，不改变IP\n\n##### 简单条件转移指令\n\n这类条件转移指令只对**单个条件标志**进行检测，并根据检测结果决定是转移执行还是顺序执行\n\n![包括](/assets/post_img/汇编语言/12.png)\n\n![包括](/assets/post_img/汇编语言/13.png)\n\n##### 无符号数比较转移指令\n\n\n\n这类条件转移指令根据对两个**无符号数**的比较结果，决定转移执行或顺序执行\n\n对无符号的比较用**CMP**指令\n\n![包括](/assets/post_img/汇编语言/14.png)\n\n##### 有符号数的比较转移指令\n\n这类条件转移指令根据对两个**有符号数**的比较结果，决定转移执行或顺序执行\n\n对有符号的比较用**CMP**指令\n\n![包括](/assets/post_img/汇编语言/15.png)\n\n#### 循环指令\n\n将一段程序**连续**、**重复**执行多次，就形成了**循环**\n\n从程序控制的角度来说，循环是由转移指令**向后转**形成的\n\n有**确定重复次数**的循环称为**计数型循环**，可用一个**循环计数器**来控制循环的次数\n\n没有确定的重复次数，只在某个**特定的条件**成立时执行循环，而当条件不成立时结束循环，这称为**条件型循环**。条件型循环用条件转移指令控制即可\n\n下面的循环指令用于控制计数型循环\n\n指令格式：LOOP label;；label为**循环入口指令**标号\n\n指令功能：LOOP指令用于控制**计数型循环**，作为循环程序段的最后一条指令。**循环计数器**指定用**CX寄存器**，采用**减1计数**方式，初值为循环次数；CX未减到0时，转移到标号label处，继续循环；CX减到0时，循环结束\n\nLOOP指令的功能等效于以下两条指令的组合\n\n```assembly\nDEC CX\nJNZ label\n```\n\n> 注意：LOOP指令的转移范围为**段内短距离转移**\n\n#### 处理器控制类指令\n\n这类指令用于强行设置某些标志，或改变处理器的某些工作方式\n\n![包括](/assets/post_img/汇编语言/16.png)\n\n![包括](/assets/post_img/汇编语言/17.png)\n\n## 串操作类指令：\n\n### 基本串操作指令\n\n#### 串传送（MOVS）类指令\n\nMOVS类指令将源串指针所指的串元素值，传送到目的串指针所指的串元素位置\n\n![包括](/assets/post_img/汇编语言/18.png)\n\n#### 串比较（CMPS）类指令\n\nCMPS类指令主要用于比较两个**等长的串**是否**完全相同**。其方法时比较两个串对应位置上的串元素是否都相同\n\n![包括](/assets/post_img/汇编语言/19.png)\n\n#### 串搜索（SCAS）类指令\n\nSCAS类指令主要用于在一个串（目的串）中**搜索**（查找）一个特定的**串元素**。其方法是将需要查找的元素值与串中各个串元素依次进行比较\n\n![包括](/assets/post_img/汇编语言/20.png)\n\n#### 串存数（STOS）类指令\n\nSTOS类指令用于将一个元素值**存入目的串**指针所指的串元素中\n\n![包括](/assets/post_img/汇编语言/21.png)\n\n### 串操作的重复前缀\n\n**重复前缀**置于基本串操作指令之前，用于控制基本串操作指令的**连续、重复执行**。重复前缀指定使用CX寄存器作为重复次数计数器，且采用**减1计数**方式\n\n#### REP前缀\n\n![包括](/assets/post_img/汇编语言/22.png)\n\n#### REPE/REPZ前缀\n\n![包括](/assets/post_img/汇编语言/23.png)\n\n#### REPNE/REPNZ前缀\n\n![包括](/assets/post_img/汇编语言/24.png)","tags":["汇编"],"categories":["Assembly"]},{"title":"java:基于socket通信技术实现的简单聊天室","url":"/2025/06/02/基于socket通信技术实现的简单聊天室/","content":"\n# [java]基于socket通信技术实现的简单聊天室\n\n## 引言\n\nsocket，你也许没听说过，但你不可能没用到过(~~除非你21世纪以来没有接触过电子产品~~)。常见如QQ，微信，只要存在聊天框和评论的地方，socket都发挥着它的作用。本文章将会分**三大模块**(socket后端编程，数据库，UI编程)，带你DIY一个属于自己的**聊天室**。\n\n本项目已在GitHub开源：[Torchman005/Simple-Chat-Room](https://github.com/Torchman005/Simple-Chat-Room)\n\n> socket核心模块：了解客户端与服务端之间信息传递的原理，手刃客户端，服务端\n>\n> 数据库模块：学习如何保存用户信息、群聊信息，实现数据的持久化\n>\n> UI模块：为用户提供一个易于操作的窗口，美化聊天室，降低使用门槛\n\n本项目需要的工具：jdk17(本人使用)，IDEA，maven(IDEA有自带的)，Navicat，mysql，javaFX相关依赖，JDBC相关依赖，最低2C2G云服务器，Xterminal(只要能连接服务器就行)，~~一个会思考的大脑~~\n\n需要会的东西：JavaSE基础，sql语句，数据库操作，maven依赖管理，Linux基本命令，docker操作(不作硬性要求)\n\n------\n\n\n\n## socket核心java编程\n\n### 简介\n\n**socket**编程属于网络编程的一种经典方式，我们可以通过socket关键字实现网络上的通信。socket(插座)，我们可以把它抽象的理解为客户端和服务端都需要一个socket插座，通过网络将这两个插座连接来实现客户端与客户端、客户端与服务端之间信息的传递。\n\n> 一般的大型项目会使用**WebSocket**技术以及**Netty**+**SpringBoot**来支持大用户量的服务，但本文仅提供了聊天室的入门小项目教程，遂采用传统**socket**实现聊天功能\n\n### 环境准备\n\n#### JDK下载及环境变量配置\n\n鉴于欲编写本项目的人应基本掌握**Java**基础，这里我会一笔带过\n\n因为本项目是基于java语言编程，所以需要从Java官网下载对应版本的**JDK**\n\n***Java**官网*：[https://www.java.com/zh-CN/](https://www.java.com/zh-CN/)\n\n下载安装包后双击安装程序，选择安装路径(可以保持默认)，然后一直点下一步，选项都保持默认，直至安装完成\n\n安装完成以后在高级系统设置中添加**Path**\n\n> 如果这些东西还需要我详细说的话，建议先从Java基础开始学起→_→\n\n### 项目编程\n\n#### 开始\n\n首先我们要在**IDEA**中新建**maven**项目，然后在**main**目录下创建包，以下是我文件的目录结构\n\n![客户端](/assets/post_img/socket项目/1.png)![服务端](/assets/post_img/socket项目/2.png)\n\n> 说明：\n>\n> **cfg**存放配置文件\n>\n> **service**存放一些聊天功能如私聊、群聊的实现类\n>\n> **chatcommon**存放User用户类和Message信息类，客户端与服务端需保持一致\n>\n> **utils**为工具包，存放自己写的方便编程的工具类\n>\n> **main**和**chatframe**分别为客户端和服务端的启动类\n\n#### chatcommon\n\n我们先从这个包入手，因为客户端与服务端的信息传递都靠这个包中的类，只有写完其中的类才能实现双端交互\n\n**User**类：\n\n```java\npackage com.jinyu.chatcommon;\n\nimport java.io.Serializable;\n\npublic class User implements Serializable {\n//    指定序列化版本号\n    private static final long serialVersionUID = 1L;\n    private String userId; // 用户Id属性\n    private String pwd; // 密码属性\n    private String userType; // 用户信息类型(判断用户是登录还是注册)\n\n    public String getUserType() {\n        return userType;\n    }\n\n    public void setUserType(String userType) {\n        this.userType = userType;\n    }\n\n    public User(String userId, String pwd) {\n        this.userId = userId;\n        this.pwd = pwd;\n    }\n\n    public User() {\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"userId='\" + userId + '\\'' +\n                \", pwd='\" + pwd + '\\'' +\n                '}';\n    }\n\n    public String getUserId() {\n        return userId;\n    }\n\n    public void setUserId(String userId) {\n        this.userId = userId;\n    }\n\n    public String getPwd() {\n        return pwd;\n    }\n\n    public void setPwd(String pwd) {\n        this.pwd = pwd;\n    }\n}\n\n```\n\n声明了用户的**userId**、**pwd**，添加了构造方法和**getter**,**setter**方法，并重写了**toString**方法\n\n\n\n**UserType**接口\n\n```java\npackage com.jinyu.chatcommon;\n\npublic interface UserType {\n    String USER_LOGIN = \"1\"; // 用户登录\n    String USER_REGISTER = \"2\"; // 用户注册\n}\n\n```\n\n这个接口用来设定客户端发送给服务端的用户信息类型，判断是要登录还是要注册\n\n\n\n**Message**类：\n\n```java\npackage com.jinyu.chatcommon;\n\nimport java.io.Serializable;\nimport java.util.PrimitiveIterator;\nimport java.util.Queue;\n\npublic class Message implements Serializable {\n    // 指定序列化版本号\n    private static final long serialVersionUID = 1L;\n    private String sender; // 发送者Id\n    private String getter; // 接收者Id\n    private String content;// 发送内容\n    private String sendTime; // 发送时间\n    private String mesType;// 消息类型（接口定义）\n\n    // 和文件相关的字段\n    private byte[] fileBytes; // 用来读取文件的字节数组\n    private int fileLen = 0;\n    private String dest;// 文件传输到哪里\n    private String src;// 文件源路径\n    private Queue<String> groupMembers; // 群组用户队列，临时存储群聊成员\n    private Queue<String> onlineUsers; // 在线用户队列，临时存储在线用户\n    private boolean isUser; // 判断有无此用户\n    private boolean isGroup; // 判断有无此群聊\n    private String groupName; // 群聊名称\n\n    public Message() {\n    }\n\n    public Message(String mesType, String content) {\n        this.mesType = mesType;\n        this.content = content;\n        this.sendTime = new java.util.Date().toString();\n    }\n\n    public Message(String mesType) {\n        this.mesType = mesType;\n        this.sendTime = new java.util.Date().toString();\n    }\n\n    public boolean isUser() {\n        return isUser;\n    }\n\n    public void setUser(boolean user) {\n        isUser = user;\n    }\n\n    public boolean isGroup() {\n        return isGroup;\n    }\n\n    public void setGroup(boolean group) {\n        isGroup = group;\n    }\n\n    public Queue<String> getOnlineUsers() {\n        return onlineUsers;\n    }\n\n    public void setOnlineUsers(Queue<String> onlineUsers) {\n        this.onlineUsers = onlineUsers;\n    }\n\n    public Queue<String> getGroupMembers() {\n        return groupMembers;\n    }\n\n    public void setGroupMembers(Queue<String> groupMembers) {\n        this.groupMembers = groupMembers;\n    }\n\n    public String getGroupName() {\n        return groupName;\n    }\n\n    public void setGroupName(String groupName) {\n        this.groupName = groupName;\n    }\n\n    public byte[] getFileBytes() {\n        return fileBytes;\n    }\n\n    public void setFileBytes(byte[] fileBytes) {\n        this.fileBytes = fileBytes;\n    }\n\n    public int getFileLen() {\n        return fileLen;\n    }\n\n    public void setFileLen(int fileLen) {\n        this.fileLen = fileLen;\n    }\n\n    public String getDest() {\n        return dest;\n    }\n\n    public void setDest(String dest) {\n        this.dest = dest;\n    }\n\n    public String getSrc() {\n        return src;\n    }\n\n    public void setSrc(String src) {\n        this.src = src;\n    }\n\n    public String getSender() {\n        return sender;\n    }\n\n    public void setSender(String sender) {\n        this.sender = sender;\n    }\n\n    public String getGetter() {\n        return getter;\n    }\n\n    public void setGetter(String getter) {\n        this.getter = getter;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public String getSendTime() {\n        return sendTime;\n    }\n\n    public void setSendTime(String sendTime) {\n        this.sendTime = sendTime;\n    }\n\n    public String getMesType() {\n        return mesType;\n    }\n\n    public void setMesType(String mesType) {\n        this.mesType = mesType;\n    }\n}\n\n```\n\n\n\n**Message**接口(主要设置消息类型)：\n\n```java\npackage com.jinyu.chatcommon;\n\npublic interface MessageType {\n    String MESSAGE_LOGIN_SUCCEED = \"1\";//登录成功的消息\n    String MESSAGE_LOGIN_FAIL = \"2\";//登录失败的消息\n    String MESSAGE_COMM_MES = \"3\";//Message和User对象接受消息\n    String MESSAGE_REQ_ONLINE_USERS = \"4\";//请求返回在线用户列表\n    String MESSAGE_RET_ONLINE_USERS_LIST = \"5\";//返回在线用户列表\n    String MESSAGE_CLIENT_EXIT = \"6\";//用户退出\n    String MESSAGE_TO_GROUP_MES = \"7\";//群发消息\n    String MESSAGE_FILE_MES = \"8\";//文件发送\n    String MESSAGE_PULL_GROUP_MES = \"9\";//拉群\n    String MESSAGE_SEND_TO_ALL = \"10\";//服务端推送新闻\n    String MESSAGE_SYSTEM = \"11\";//系统消息\n    String MESSAGE_REGISTER = \"12\";//注册\n    String MESSAGE_REGISTER_SUCCEED = \"12\";//注册成功\n    String MESSAGE_REGISTER_FAIL = \"13\";//注册失败\n}\n\n```\n\n通过设置消息类型(**MessageType**)来让服务端识别不同的功能请求，从而实现不同的功能\n\n#### chatmain/chatframe\n\n这两个包下都分别只有一个类，那就是程序的启动入口(主类)\n\n客户端：\n\n```java\npackage com.jinyu.main;\n\nimport com.jinyu.ui.LoginUI;\n\nimport javafx.application.Application;\n\npublic class ChatMain {\n    public static void main(String[] args) {\n        // 设置系统属性，解决中文乱码\n        System.setProperty(\"file.encoding\", \"UTF-8\");\n        // 启动JavaFX应用\n        Application.launch(LoginUI.class, args);\n    }\n}\n```\n\n这个**main**方法启动的是UI界面，UI的逻辑全部写在**ui**这个包下\n\n服务端：\n\n```java\npackage com.jinyu.chatframe;\n\nimport com.jinyu.chatserver.service.ChatServer;\nimport java.io.IOException;\n\npublic class ChatFrame {\n    public static void main(String[] args) throws Exception {\n        new ChatServer();\n    }\n}\n```\n\n通过new个**ChatServer**对象来启动服务端\n\n#### resources\n\nresources中专门存放项目的各种配置文件，在这个项目中，我们要写的配置文件十分简单\n\n客户端：\n\n```properties\n#配置文件我命名为config.properties，所以下文会用config指代这个文件\nhost=127.0.0.1\nport=2323\n```\n\n这里配置了要连接的服务器的ip和端口\n\n服务端：\n\n```properties\nport=2323\n```\n\n#### service\n\n##### 注册与登录功能\n\n***前言***\n\n无论是注册还是登录，都需要用户的信息，而用户的信息需要用户自己在UI界面给的输入框中输入回车才会读取，所以在**LoginUI**和**RegisterUI**类中，我会读取输入框用户输入的数据，紧接着调用**ToUserFunction**中的注册和登录方法并传入参数\n\n> 关于UI方面都会在第三模块中解释，所以在这里不作代码演示，我们直接来看service中的逻辑<(￣︶￣)↗[GO!]\n\n![ToUserFunction类](/assets/post_img/socket项目/3.png)\n\n***注册***\n\n众所周知，不管你用哪个应用或上哪个网站，用户都得先注册账号，将用户信息存储在数据库才能够使用原有账号密码登录，所以我这里先介绍注册的逻辑及实现\n\n客户端：\n\n```java\n// ToUserFunction类\npublic boolean registerUser(String userId, String pwd) {\n    boolean b = false;\n    try {\n        // 读取配置文件\n        ClassLoader classLoader = ToUserFunction.class.getClassLoader();\n        InputStream input = classLoader.getResourceAsStream(\"config.properties\");\n        Properties prop = new Properties();\n        prop.load(input);\n        String host = prop.getProperty(\"host\");\n        String sport = prop.getProperty(\"port\");\n        int port = Integer.parseInt(sport);\n\n        // 创建socket连接\n        socket = new Socket(InetAddress.getByName(host), port);\n\n        // 向服务端传输用户信息\n        user.setUserId(userId);\n        user.setPwd(pwd);\n        user.setUserType(UserType.USER_REGISTER);\n        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\n        oos.writeObject(user); \n\n        // 接收服务端回复的注册信息\n        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n        Message mes = (Message)ois.readObject();\n\n        // 判断注册是否成功\n        if(mes.getMesType().equals(MessageType.MESSAGE_REGISTER_SUCCEED)) {\n            b = true;\n        } else {\n            displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"注册失败(用户名已存在)\"));\n            socket.close();\n        }\n    } catch (Exception e) {\n        displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"注册失败: \" + e.getMessage()));\n    }\n    return b;\n}\n```\n\n> 这个是用户在客户端的注册实现，我们来剖析一下\n\n首先，我们需要让客户端与服务端建立连接，就需要用到socket\n\n```java\nSocket socket = new Socket(InetAddress.getByName(host), port);\n```\n\n这里我们首先创建了一个**socket**对象，其中的参数分别是你要连接的服务器的**InetAddress**对象和所在端口号(这里解释一下，**InetAddress**类中的**getByName**方法是利用主机的IP地址来返回**InetAddress**对象的)，所以要读取**resources**中的配置文件(**config**)\n\n此时服务端需要监听来自客户端**socket**的动作，客户端与服务端之间才能建立连接，于是在**服务端**写出如下代码：\n\n```java\n// ChatServer类\nServerSocket ss = null;\npublic ChatServer() throws Exception{\n\n    try {\n        //             启动推送新闻的线程\n        new Thread(new SendNewsToAllService()).start();\n        //            读取配置文件\n        ClassLoader classLoader = ChatServer.class.getClassLoader();\n        InputStream input = classLoader.getResourceAsStream(\"config.properties\");\n        Properties prop = new Properties();\n        prop.load(input);\n        String sport = prop.getProperty(\"port\");\n        int port = Integer.parseInt(sport);\n        System.out.println(\"服务端在\" + port + \"端口监听\");\n        ss = new ServerSocket(port);\n\n        while(true){\n            Socket socket = ss.accept();// 监听客户端的连接，若没有则阻塞\n            //                对象输入输出流读取用户对象\n            ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\n            User user = (User) ois.readObject();\n            //                准备一个Message对象，用来回复客户端\n            Message message = new Message();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            ss.close();\n        }\n    }\n```\n\n这整个代码都是在**ChatServer**这个类的构造方法中执行的，保证服务端启动后这些代码会立即执行\n\n可以看出，服务端首先也是读取配置文件，创建**ServerSocket**对象，把从配置文件读取的端口号(**port**)作为参数传入\n\n```java\nServerSocket ss = new ServerSocket(port);\n```\n\n然后调用**ServerSocke**t的**accept**方法来监听客户端连接\n\n```java\nSocket socket = ss.accept();\n```\n\n> 注意：因为将会有多个客户端登录，所以客户端只监听一次是远远不够的，这时就需要在外面包裹一层**while循环**来持续监听\n\n***至此，客户端与服务端之间已建立连接***\n\n> 服务端就先告一段落，让我们回到客户端\n\n客户端：\n\n```java\n// ToUserFunction类\n\n// 向服务端传输用户信息\nuser.setUserId(userId);\nuser.setPwd(pwd);\nuser.setUserType(UserType.USER_REGISTER);\n```\n\n用户的注册，就是要把用户输入的信息传到服务端，让服务端写入数据库\n\n这里的目的，就是封装好**User对象**，set好User的**Id**，**pwd**和**你此次传输的用户信息类型(UserType)**，然后通过IO流传给服务端\n\n下面，是创建**ObjectInputStream**和**ObjectOutputStream**来读写**User对象**\n\n```java\n// ToUserFunction类\n\nObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\noos.writeObject(user); \n// 接收服务端回复的注册信息\nObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\nMessage mes = (Message)ois.readObject();\n\n// 判断注册是否成功\nif(mes.getMesType().equals(MessageType.MESSAGE_REGISTER_SUCCEED)) {\n    b = true; // 判定为成功，返回true\n} else {\n    displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"注册失败(用户名已存在)\"));\n    socket.close();\n}\n} catch (Exception e) {\n    displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"注册失败: \" + e.getMessage()));\n}\n```\n\n**ObjectOutputStream**写入服务端的socket后，服务端读入\n\n```java\n// ChatServer类\n\nObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n User user = (User) ois.readObject();\n// 准备个message对象来承载信息并发送至客户端\nMessage message = new Message();\n```\n\n读入以后就要判断这个User的类型了，判断它是登录还是注册\n\n```java\nif(user.getUserType().equals(UserType.USER_REGISTER)){\n    //这里涉及数据库SQL操作，暂不作处理\n    //注册成功\n    message.setMesType(MessageType.MESSAGE_REGISTER_SUCCEED);\n    } else {\n        //注册失败\n        message.setMesType(MessageType.MESSAGE_REGISTER_FAIL);\n    }\n    oos.writeObject(message);\n}\n```\n\n随后将message传给客户端\n\n`oos.writeObject(message);`\n\n客户端：\n\n```java\n// ToUserFunction类\n\n// 接收服务端回复的注册信息\nObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\nMessage mes = (Message)ois.readObject();\n\n// 判断注册是否成功\nif(mes.getMesType().equals(MessageType.MESSAGE_REGISTER_SUCCEED)) {\n    b = true;\n} else {\n    displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"注册失败(用户名已存在)\"));\n    socket.close();\n}\n```\n\n客户端接收到来自客户端注册成功与否的信息，并将结果返回\n\n> 注册逻辑已完成o(*￣︶￣*)o\n\n***登录***\n\n其实登录的大体逻辑和注册差不多，只不过多了验证Id、密码和创建用户线程的步骤\n\n客户端：\n\n```java\n// ToUserFunction类\n\npublic boolean checkUser(String userId, String pwd){\n    //        给登录的用户账号和密码初始化，便于后续验证\n    user.setUserId(userId);\n    user.setPwd(pwd);\n    user.setUserType(UserType.USER_LOGIN);\n\n    boolean b = false;\n    try {\n        // 读取配置文件\n        ClassLoader classLoader = ToUserFunction.class.getClassLoader();\n        InputStream input = classLoader.getResourceAsStream(\"config.properties\");\n        Properties prop = new Properties();\n        prop.load(input);\n        String host = prop.getProperty(\"host\");\n        String sport = prop.getProperty(\"port\");\n        int port = Integer.parseInt(sport);\n\n        // 创建socket连接\n        socket = new Socket(InetAddress.getByName(host), port);\n\n        //            向服务端传输用户信息，传的是对象\n        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\n        oos.writeObject(user);\n\n    return b;\n}\n```\n\n服务端：\n\n```java\n// ChatServer类\n\nif(user.getUserType().equals(UserType.USER_LOGIN)){\n    //                然后再验证是否能够成功登录\n    if(/*这里需要使用SQL语句检索数据库并比对来判断用户Id和密码的合理性*/){\n        message.setMesType(MessageType.MESSAGE_LOGIN_SUCCEED);\n        //                    加入线程\n        ServerConnectClientThread thread = new ServerConnectClientThread(socket, user.getUserId());\n        thread.start();\n        ClientThreadsManage.addServerConnectClientThread(user.getUserId(), thread);\n\n        //                    将用户Id加入在线用户队列\n        OnlineUsers.addOnlineUsers(user.getUserId());\n\n        //                    然后把message传给客户端\n        oos.writeObject(message);\n    }else{\n        //                    登录失败\n        System.out.println(\"用户账号或密码不正确\");\n        message.setMesType(MessageType.MESSAGE_LOGIN_FAIL);\n        oos.writeObject(message);\n        socket.close();\n    }\n}\n```\n\n服务端验证用户Id和密码是否匹配，若匹配则登陆成功，给**message**设置登陆成功的类型，并增加对应用户线程\n\n客户端：\n\n```java\n//            还要接受服务端回复的登录信息\nObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\nMessage mes = (Message)ois.readObject();\n\n//            判断登录是否成功\nif(mes.getMesType().equals(MessageType.MESSAGE_LOGIN_SUCCEED)){\n    b = true;\n    //                因为登录成功，所以新增一个通信线程\n    ClientConnectServerThread thread = new ClientConnectServerThread(socket, chatUI);\n    //                启动线程\n    thread.start();\n    //                把这个线程存到map集合中统一管理\n    ClientConnServerThreadsManage.addClientConnectServerThread(userId, thread);\n\n}else{\n    displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"用户名或密码不正确\"));\n    socket.close();\n}\n} catch (Exception e) {\n    displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"登录失败: \" + e.getMessage()));\n}\n```\n\n客户端再次接收到服务端传来的信息，确定自己是登录成功还是登录失败，若登陆成功则添加自身对应线程\n\n\n\n> 这里遇到了一个新的内容：线程\n\n认真思考的人已经注意到了，既然这里new了一个新线程，那这个线程类的内容是什么呢？\n\n如你所见，下面分别是客户端和服务端的线程类：\n\n客户端：\n\n```java\n// ClientConnectServerThread类\n\npackage com.jinyu.chatclient.service;\n\nimport com.jinyu.chatcommon.Message;\nimport com.jinyu.chatcommon.MessageType;\nimport com.jinyu.ui.ChatUI;\nimport com.jinyu.utils.Utility;\n\nimport javax.management.ObjectName;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.net.Socket;\nimport java.util.Queue;\n\npublic class ClientConnectServerThread extends Thread{\n    //    全局变量事先声明\n    private Socket socket;\n    private ChatUI chatUI;\n\n    public ClientConnectServerThread(Socket socket,ChatUI chatUI){\n        this.socket = socket;\n        this.chatUI = chatUI;\n    }\n    @Override\n    public void run() {\n        //        while循环来持续接收服务端传来的信息\n        while (true) {\n            //            等待读取\n            //            System.out.println(\"(等待读取)\");\n\n            try {\n                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n                Message mes = (Message) ois.readObject();\n                //            等待服务端传来message\n                if (mes.getMesType().equals(MessageType.MESSAGE_RET_ONLINE_USERS_LIST)) {\n                    //                服务端的信息是返回在线用户列表，所以这里等待接收\n                    Queue<String> onlineUsers = mes.getOnlineUsers();\n                    chatUI.updateOnlineUsers(onlineUsers);\n                } else if (mes.getMesType().equals(MessageType.MESSAGE_COMM_MES)) {\n                    //                普通的聊天消息\n                    chatUI.displayMessage(mes);\n                } else if(mes.getMesType().equals(MessageType.MESSAGE_FILE_MES)){\n                    chatUI.displayMessage(mes);\n                    // 文件保存逻辑将在UI中处理\n                } else if(mes.getMesType().equals(MessageType.MESSAGE_SEND_TO_ALL)){\n                    //                    服务端推送消息\n                    chatUI.displayMessage(mes);\n                } else if(mes.getMesType().equals(MessageType.MESSAGE_TO_GROUP_MES)){\n                    if(mes.isGroup()){\n                        chatUI.displayMessage(mes);\n                    } else{\n                        chatUI.displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"无此群聊＞﹏＜\"));\n                    }\n                } else {\n                    chatUI.displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"其他类型的信息，暂时不做处理\"));\n                }\n\n            } catch (Exception e) {\n                chatUI.displayMessage(new Message(MessageType.MESSAGE_SYSTEM, \"接收消息错误: \" + e.getMessage()));\n                break;\n            }\n        }\n    }\n    public Socket getSocket(){\n        return socket;\n    }\n}\n```\n\n服务端：\n\n```java\n// ServerConnectClientThread类\n\npackage com.jinyu.chatserver.service;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.net.Socket;\nimport java.util.Iterator;\nimport java.util.Queue;\n\nimport com.jinyu.chatcommon.Message;\nimport com.jinyu.chatcommon.MessageType;\n\npublic class ServerConnectClientThread extends Thread{\n    private Socket socket;\n    private String userId;\n    public ServerConnectClientThread(Socket socket, String userId){\n        this.socket = socket;\n        this.userId = userId;\n    }\n    public Socket getSocket(){\n        return this.socket;\n    }\n    @Override\n    public void run(){\n        while(true){\n            try {\n                System.out.println(userId + \"已连接并保持通信\");\n                ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n                Message mes = (Message) ois.readObject();\n                //                获取在线用户列表并且发给客户端\n                if(mes.getMesType().equals(MessageType.MESSAGE_REQ_ONLINE_USERS)){\n                    System.out.println(mes.getSender() + \"请求获取在线用户列表\");\n                    Queue<String> onlineUsers = ClientThreadsManage.getOnlineUsers();\n                    Message mes2 = new Message();\n                    mes2.setMesType(MessageType.MESSAGE_RET_ONLINE_USERS_LIST);\n                    mes2.setOnlineUsers(onlineUsers);\n                    mes2.setGetter(mes.getSender());\n\n                    ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\n                    oos.writeObject(mes2);\n                }else if(mes.getMesType().equals(MessageType.MESSAGE_CLIENT_EXIT)){\n                    //                    调用方法\n                    ClientThreadsManage.removeSCCThread(mes.getSender());\n                    System.out.println(userId + \"退出登录\");\n                    OnlineUsers.deleteUser(userId);\n                    socket.close(); // 关闭socket连接\n                    break;\n                }else if(mes.getMesType().equals(MessageType.MESSAGE_COMM_MES)){\n                    //                    私聊转发\n                    ObjectOutputStream oos = null;\n                    try {\n                        oos = new ObjectOutputStream(ClientThreadsManage.getServerConnectClientThread(mes.getGetter()).getSocket().getOutputStream());\n                        oos.writeObject(mes);//若要离线留言，可发送给数据库\n                    } catch (Exception e) {\n                        System.out.println( mes.getGetter() + \"不在线，无法私聊\");\n                    }\n                } else if(mes.getMesType().equals(MessageType.MESSAGE_FILE_MES)){\n                    //                    文件转发\n                    ServerConnectClientThread thread = ClientThreadsManage.getServerConnectClientThread(mes.getGetter());\n                    ObjectOutputStream oos = new ObjectOutputStream(thread.getSocket().getOutputStream());\n                    oos.writeObject(mes);\n                } else if(mes.getMesType().equals(MessageType.MESSAGE_PULL_GROUP_MES)) {\n                    //                    拉群，并将群存储\n                    Groups.addGroup(mes.getGroupName(), mes.getGroupMembers());\n                } else if(mes.getMesType().equals(MessageType.MESSAGE_TO_GROUP_MES)){\n                    //                    群发消息\n                    //                    判断是否有此群聊\n                    if(Groups.hasGroup(mes.getGroupName())){\n                        mes.setGroup(true);\n                        Queue<String> group = Groups.getGroup(mes.getGroupName());\n                        Iterator<String> iterator = group.iterator();\n                        while(iterator.hasNext()){\n                            String onlineUser = iterator.next();\n                            if(!onlineUser.equals(mes.getSender())){\n                                //                            排除发消息的用户\n                                ObjectOutputStream oos = new ObjectOutputStream(ClientThreadsManage.getServerConnectClientThread(onlineUser).getSocket().getOutputStream());\n                                oos.writeObject(mes);\n                            }\n                        }\n                    } else{\n                        //                        将不存在群组的信息发送给客户端\n                        System.out.println(\"不存在此群聊\");\n                        mes.setGroup(false);\n                        ObjectOutputStream oos = new ObjectOutputStream(ClientThreadsManage.getServerConnectClientThread(mes.getSender()).getSocket().getOutputStream());\n                        oos.writeObject(mes);\n                    }\n                } else{\n                    System.out.println(\"其他类型的信息，暂时不作处理\");\n                }\n            } catch (IOException e) {\n                // 处理客户端异常断开连接的情况\n                System.out.println(userId + \"退出登录\");\n                ClientThreadsManage.removeSCCThread(userId);\n                OnlineUsers.deleteUser(userId);\n                try {\n                    socket.close();\n                } catch (IOException ex) {\n                    ex.printStackTrace();\n                }\n                break;\n            } catch (ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```\n\n客户端和服务端的线程类代码看似很长，其实逻辑很简单，那就是接收来自服务端/客户端的信息，判断信息的类型来实现相应的**代码/功能**\n\n创建这些线程后，得需要有一个专门的单位去管理它们，于是就出现了线程管理类\n\n客户端：\n\n```java\n// ClientConnServerThreadManage类\n\npackage com.jinyu.chatclient.service;\n\nimport java.util.HashMap;\n\n/*\n用来管理每个用户线程的类（用map集合存储）\n */\npublic class ClientConnServerThreadsManage {\n    private static HashMap<String, ClientConnectServerThread> hm = new HashMap<>();\n\n\n    //    添加用户线程\n    public static void addClientConnectServerThread(String userId, ClientConnectServerThread thread) {\n        hm.put(userId, thread);\n    }\n\n    //    根据userId获取用户线程\n    public static ClientConnectServerThread getClientConnectServerThread(String userId) {\n        return hm.get(userId);\n    }\n// 删除线程\n    public static void removeCCSThread(String userId){\n        hm.remove(userId);\n    }\n}\n```\n\n服务端：\n\n```java\n// ClientThreadsManage类\n\npackage com.jinyu.chatserver.service;\n\nimport java.util.HashMap;\nimport java.util.Queue;\n\npublic class ClientThreadsManage {\n    private static HashMap<String, ServerConnectClientThread> threads = new HashMap<>();\n\n    public static HashMap<String, ServerConnectClientThread> getThreads() {\n        return threads;\n    }\n\n    public static void addServerConnectClientThread(String userId, ServerConnectClientThread serverConnectClientThread){\n\n        threads.put(userId, serverConnectClientThread);\n\n    }\n    public static ServerConnectClientThread getServerConnectClientThread(String userId){\n        return threads.get(userId);\n    }\n    public static Queue<String> getOnlineUsers(){\n        return OnlineUsers.onlineUsers;\n    }\n    public static void removeSCCThread(String userId){\n        threads.remove(userId);\n    }\n}\n```\n\n每次创建线程之后，需将线程纳入线程管理类，将线程都放入一个集合统一管理\n\n> 了解完线程的大体内容之后，我们再回到登录逻辑\n\n添加好对应用户的线程之后，这名用户便成为了我们平常所说的**在线用户**\n\n登录已完成，看似复杂，实际上只要捋清楚每个类的职责，并不困难(~~迫真~~)\n\n##### 私聊功能\n\n> 其实本项目的大体框架已经完成，剩下的功能实现逻辑都很相似，我在这就先就着一个典型例子详细介绍\n\n就比如私聊逻辑，一开始客户端选择进行私聊，并将发送者ID(**senderId**)、接收者ID(**getterId**)、发送的内容(**content**)、消息类型(**MessageType**)封装进message对象中发送给服务端\n\n```java\n// ClientMessageService类\n\npublic void sendMessageToOne( String content, String senderId, String getterId){\n    //        实现私聊\n    //        封装message\n    Message mes = new Message();\n    mes.setMesType(MessageType.MESSAGE_COMM_MES);\n    mes.setSender(senderId);\n    mes.setContent(content);\n    mes.setGetter(getterId);\n    mes.setSendTime(new Date().toString());//发送时间\n    System.out.println(\"\\n\" + mes.getSendTime() + \"  \" + mes.getSender() + \": \" + mes.getContent());\n\n    try {\n        ObjectOutputStream oos = new ObjectOutputStream(ClientConnServerThreadsManage.getClientConnectServerThread(senderId).getSocket().getOutputStream());\n        oos.writeObject(mes);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n服务端接收信息的代码就由线程类来执行\n\n```java\n// ServerConnectClientThread类\n\nif(mes.getMesType().equals(MessageType.MESSAGE_COMM_MES)){\n    //                    私聊转发\n    ObjectOutputStream oos = null;\n    try {\n        oos = new ObjectOutputStream(ClientThreadsManage.getServerConnectClientThread(mes.getGetter()).getSocket().getOutputStream());\n        oos.writeObject(mes);//若要离线留言，可发送给数据库\n    } catch (Exception e) {\n        System.out.println( mes.getGetter() + \"不在线，无法私聊\");\n    }\n}\n```\n\nOK，服务端接收了来自客户端的**message**，那么服务端在这里就起到一个转发的作用，有了getterId，我们就可以从线程管理类中找到这个getterId对应的线程，服务端就可以准确地把**message**发送给这个客户端，接收者接收到**message**以后，客户端线程就会再次判断信息的类型，如果是私聊类型，便会输出私聊消息的内容到指定区域\n\n##### 其他功能\n\n> 私聊功能已完成，其他功能大同小异，我不会再详细剖析，我会交代一些细节，读者可以自己尝试实现\n\n**获取在线用户列表**：实现这个功能主要在于如何获取在线用户Id，而我们知道判断一个用户是否在线就要看线程集合中有没有这个用户Id对应的线程，所以，我们可以遍历线程集合来获取在线用户的Id并传给客户端\n\n**创建群聊**：拉群需要知道群聊名、在线用户都有谁，我们可以将每个群的群成员放入到一个队列中，再将群聊放入一个HashMap中集中管理，key为群聊名，value为用户队列\n\n**群聊**：跟私聊的逻辑实现差不多，只不过这个要发给好几个人，就要在要发的群聊的用户队列中遍历用户来传信息\n\n**文件发送**：跟私聊，群聊很相似，唯一不同就是要使用File的IO流来传文件\n\n**服务端新闻推送**：主要还是遍历，遍历每个在线客户端，给它们发消息，并且用while循环不断读取需要发送的消息\n\n**无异常退出**：这个需要在用户想要退出的时候，服务端从管理线程的集合中移除该用户线程\n\n**后端模块已基本完成，现在你就可以打开服务端，多开客户端来在控制台体验一下自己写的无UI聊天室**\n","tags":["java","socket"],"categories":["java"]},{"title":"Minecraft模组编写教程","url":"/2025/01/13/Minecraft模组编写教程/","tags":["Minecraft"],"categories":["Minecraft"]},{"title":"Go语言基本语法","url":"/2024/11/25/Go语言基本语法/","content":"\n# Go语言基本语法\n\n## Go语言介绍（特点列举）\n\n1. 高性能、高并发\n2. 语法简单、学习曲线平缓\n3. 丰富的标准库\n4. 完善的工具链\n5. 静态链接\n6. 快速编译\n7. 跨平台\n8. 垃圾回收\n\n## 开发环境\n\n### 安装Golang\n\nGolang官网\n\nhttps://go.dev/\n\nhttps://studygolang.com/dl\n\nhttps://goproxy.cn/\n\n### 配置集成开发环境\n\n你可以使用vscode（下插件）或goland进行配置，其中goland是付费软件，如果想永久使用，那就从网上找个破解版吧\n\n## 基础语法（速通）\n\n相信你已经有了其他编程语言的基础（没有的话推荐先从C语言开始学习），所以后面将会只用少量代码来快速诠释语法\n\n### Hello World\n\n```\npackage main   // 属于main包的一部分，main包是程序的一个入口文件\n\nimport (     // 导入标准库里的fmt包，fmt包主要是用来对屏幕输入输出字符串，格式化字符串\n\"fmt\"\n)\n\nfunc main() {     // main函数调用了fmt.Println，输出hello world\nfmt.Println(\"hello world\")\n}\n```\n\n输出\n\n```\nhello world\n```\n\n\n\n### 变量\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() { //go语言自动推导变量类型\n\tvar a = \"initial\" // 字符串类型\n\n\tvar b, c = 1, 2 // 整数类型\n\n\tvar d = true // 布尔类型\n\n\tvar e float64  // 占8bytes，内存占用是float32的两倍，声明e为float64类型的变量\n\n\tf := float32(e)\n\n\tg := a + \"foo\"\n\tfmt.Println(a, b, c, d, e, f) // initial 1 2 true 0 0\n\tfmt.Println(g)                // initialfoo\n\n\tconst s string = \"constant\" // const常量没有确定的类型，它会根据上下文自动确定类型\n\tconst h = 500000000\n\tconst i = 3e20 / h\n\tfmt.Println(s, h, i, math.Sin(h), math.Sin(i))\n}\n```\n\n输出\n\n```\ninitial 1 2 true 0 0\ninitialfoo\nconstant 500000000 6e+11 -0.28470407323754404 0.7591864109375384\n```\n\n\n\n### if else\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main(){\nif 7%2 == 0{  // 若if后面跟小括弧，编译器会自动\n    fmt.Println(\"7 is even\")\n}else {\n    fmt.Println(\"7 is odd\")\n}\n\nif 8%4 == 0{\nfmt.Println(\"8 is divisible by 4\")\n}\n\nif num := 9;num < 0 {\n    fmt.Println(num,\"is negative\")\n}else if num < 10 {\n    fmt.Println(num,\"has 1 digit\")\n}else {\n    fmt.Println(num,\"has multiple digits\")\n}\n}\n```\n\n输出\n\n```\n7 is odd\n8 is divisible by 4\n9 has 1 digit\n```\n\n\n\n### 循环\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ti := 1\n\tfor {\n\t\tfmt.Println(\"loop\")\n\t\tbreak\n\t}\n\tfor j := 7; j < 9; j++ {\n\t\tfmt.Println(j)\n\t}\n\n\tfor n := 0; n < 5; n++ {\n\t\tif n%2 == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(n)\n\t}\n\tfor i <= 3 {\n\t\tfmt.Println(i)\n\t\ti = i + 1\n\t}\n}\n```\n\n输出\n\n```\nloop\n7\n8\n1\n3\n1\n2\n3\n```\n\n\n\n### switch\n\n```\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ta := 2\n\tswitch a {  // 可以使用任意变量类型\n\tcase 1:\n\t\tfmt.Println(\"one\")  // go的case默认不需要break\n\tcase 2:\n\t\tfmt.Println(\"two\")\n\tcase 3, 4:\n\t\tfmt.Println(\"three or four\")\n\tdefault:\n\t\tfmt.Println(\"other\")\n\t}\n\n\tt := time.Now()\n\tswitch {  // 若switch后面不跟变量，则可以在case后面加条件分支来判断\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"it's before noon\")\n\tdefault:\n\t\tfmt.Println(\"it's after noon\")\n\t}\n}\n```\n\n输出\n\n```\ntwo\nit's after noon\n```\n\n\n\n### 数组\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [5]int\n\ta[4] = 100\n\tfmt.Println(a[4], len(a))\n\n\tb := [5]int{1, 2, 3, 4, 5}\n\tfmt.Println(b)\n\n\tvar twoD [2][3]int\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\ttwoD[i][j] = i + j\n\t\t}\n\t}\n\tfmt.Println(\"2d:\", twoD)\n}\n```\n\n输出\n\n```\n100 5\n[1 2 3 4 5]\n2d: [[0 1 2] [1 2 3]]\n```\n\n### 切片（可以更改长度的数组）\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := make([]string, 3)\n\ts[0] = \"a\"\n\ts[1] = \"b\"\n\ts[2] = \"c\"\n\tfmt.Println(\"get:\", s[2])\n\tfmt.Println(\"len:\", len(s))\n\n\ts = append(s, \"d\")\n\ts = append(s, \"e\", \"f\")\n\tfmt.Println(s)\n\n\tc := make([]string, len(s))\n\tcopy(c, s)\n\tfmt.Println(c)\n\n\tfmt.Println(s[2:5])\n\tfmt.Println(s[:5])\n\tfmt.Println(s[2:])\n\n\tgood := []string{\"g\", \"o\", \"o\", \"d\"}\n\tfmt.Println(good)\n}\n```\n\n输出\n\n```\nget: c\nlen: 3\n[a b c d e f]\n[a b c d e f]\n[c d e]\n[a b c d e]\n[c d e f]\n[g o o d]\n```\n\n### map（相当于哈希或字典）\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := make(map[string]int)\n\tm[\"one\"] = 1\n\tm[\"two\"] = 2\n\tfmt.Println(m)           // map[one:1 two:2]\n\tfmt.Println(len(m))      // 2\n\tfmt.Println(m[\"one\"])    // 1\n\tfmt.Println(m[\"unknow\"]) // 0\n\n\tr, ok := m[\"unknow\"]\n\tfmt.Println(r, ok) // 0 false\n\n\tdelete(m, \"one\")\n\n\tm2 := map[string]int{\"one\": 1, \"two\": 2}\n\tvar m3 = map[string]int{\"one\": 1, \"two\": 2}\n\tfmt.Println(m2, m3)\n}\n```\n\n### 输出\n\n```\nmap[one:1 two:2]\n2\n1\n0\n0 false\nmap[one:1 two:2] map[one:1 two:2]\n```\n\n### range\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnums := []int{2, 3, 4}\n\tsum := 0\n\tfor i, num := range nums {\n\t\tsum += num\n\t\tif num == 2 {\n\t\t\tfmt.Println(\"index:\", i, \"num\", num) // index: 0 num: 2\n\t\t}\n\t}\n\tfmt.Println(sum) // 9\n\n\tm := map[string]string{\"a\": \"A\", \"b\": \"B\"}\n\tfor k, v := range m {\n\t\tfmt.Println(k, v)\n\t}\n\tfor k := range m {\n\t\tfmt.Println(\"key\", k)\n\t}\n}\n```\n\n输出\n\n```\nindex: 0 num 2\n9\na A\nb B\nkey a\nkey b\n```\n\n### 函数\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc add(a int, b int) int {\n\treturn a + b\n}\n\nfunc add2(a, b int) int {\n\treturn a + b\n}\n\nfunc exists(m map[string]string, k string) (v string, ok bool) {\n\tv, ok = m[k]\n\treturn v, ok\n}\n\nfunc main() {\n\tres := add(1, 2)\n\tfmt.Println(res)\n\n\tv, ok := exists(map[string]string{\"a\": \"A\"}, \"a\")\n\tfmt.Println(v, ok)\n}\n```\n\n输出\n\n```\n3\nA true\n```\n\n### 指针\n\n```\npackage main\n\nimport \"fmt\"\n\nfunc add2(n int) {  // 这种写法不对，因为这个n只是拷贝，是无效的\n\tn += 2\n}\n\nfunc add2ptr(n *int) {\n\t*n += 2\n}\n\nfunc main() {\n\tn := 5\n\tadd2(n)\n\tfmt.Println(n)\n\tadd2ptr(&n)\n\tfmt.Println(n)\n}\n```\n\n输出\n\n```\n5\n7\n```\n\n","tags":["Go语言"],"categories":["Golang"]},{"title":"存储与数据库——1.认识存储与数据库","url":"/2024/11/10/存储与数据库/","content":"\n# 存储与数据库——1.认识存储与数据库\n\n## 前言\n\n> 本文是参考字节跳动存储与数据库课程而编写的笔记文\n\n------\n\n\n\n## 存储\n\n### 经典案例介绍数据的产生\n\n> 有一天,李华要在QQ要在Hello Talk(一款可以与外国人交流锻炼语言能力的app)与老外交流.他注册的用户名为lihua,密码为123456,最后按下注册按钮,如此,数据便产生了,并且以极快的速度向app的后台服务器传输\n\n我们可以把这个过程剖析过来看看：\n李华的注册操作产生了一条结构化的用户注册数据→数据产生→数据飞速传输到后端服务器→数据在数据库中存储持久化保存下来(若不存储到数据库，你此前的操作都是白干，信息不会被记录)\n\n**这里面存储系统也参与了工作，这里就先不展开叙述了(懒)**\n\n> 若数据已到达数据库，它会做哪些事情呢？\n\n1. 首先，数据库会对数据进行校验，比如校验用户名是否重复，密码是否符合要求等\n2. 数据库会修改内存，用高效的数据结构组织数据并进行运算，来准备后续的持久化\n3. 数据库会将数据写入硬件，且对硬件的寿命及性能不会产生较大影响\n\n### 存储系统概览\n\n> 啥是存储系统!?w(ﾟДﾟ)w\n\n存储系统是一个提供读写、控制类接口，能够安全、高效的访问存储设备将数据持久化的软件\n\n> 存储系统有啥特点~_~\n\n1. 存储系统作为后端软件的底座，性能敏感，需要保证高吞吐和低时延\n2. 存储系统是软件架构，容易受硬件的影响（硬件发生变革，存储系统要做出改变来适应硬件的变化）\n3. 存储系统的代码必须简洁，但要应对复杂的业务逻辑（说白了就是你要用简单的代码来应对多种复杂的情况）\n\n### 存储器层级结构\n\n![这是一张层级结构概览图](/assets/post_img/存储与数据库/1.png)\n\n容量从上往下依次增大\n访问速度从上往下依次减小\n\n在中间层其实有一个兼顾存储容量和访问速度的东西叫Persistent Memory,它是介于CPU和内存之间的一个高速缓存,它的访问速度比内存快,但是容量比内存小\n\n### 数据怎么从应用到存储介质\n\n![数据链路图](/assets/post_img/存储与数据库/2.png)\n\n> 注：缓存很重要，它直接贯穿整个存储体系(可以帮助我们以硬件友好的方式来跟硬件打交道);\n拷贝很昂贵(太消耗cpu了),应尽量减少;\n硬件设备需要有抽象统一的接入层(否则如果硬件变化了，软件还得重写，很麻烦)\n\n### RAID技术\n\n> 出现背景：\n\n- 单块大容量磁盘的价格>多块小容量磁盘\n\n- 单块磁盘的写入功能<多块磁盘的并发写入性能\n- 单块磁盘的容错能力有限，不够安全\n\n> 所以,RAID技术做到了高性能/高性价比/高可靠性(很牛)\n\nRAID 0:\n\n- 多块磁盘的简单组合\n- 数据条带化存储,提高磁盘带宽\n- 没有额外的存储设计\n\nRAID 1:\n\n- 一块磁盘对应一块额外镜像盘\n- 真是空间利用率仅有50%\n- 容错能力强\n\nRAID 0+1(比如说先用RAID 0两两组合成若干个单元,再用RAID 1将这些单元两两组合):\n\n- 结合了RAID 0和RAID 1的优点\n- 真实利用率仅50%\n- 容错能力强，写入带宽好\n\n------------------------------------------------------------------------------------------------------------\n\n## 数据库\n\n### 数据库的分类及特点\n\n> 关系=集合=任意元素组成的若干有序偶对,反应了事物间的关系\n关系代数=对关系作运算的抽象查询语言(雀食抽象)\nSQL=一种DSL=方便人类阅读的关系代数表达形式\n\n关系型数据库:就是存储系统(对,它就是),但是在存储之外,又发展出其他能力(结构化数据友好、支持事务、支持复杂查询语言)\n\n非关系型数据库:也是存储系统，但是一般不要求严格的结构化(半结构化数据友好、可能支持事务、可能支持复杂查询语言)\n\n> *PS:此处描述的可能有点抽象。。。具体后面会学到*\n\n### 数据库 vs 经典存储\n\n存储方式|数据管理|事务能力|复杂查询能力\n:-|:-:|:-:|-:\n数据库|结构化管理|优越|灵活简洁\n经典存储|半结构化管理|一般|僵化复杂\n\n*事务的ACID中:\nA:事务的操作要么全做，要么不做\nC:事务执行前后,数据状态是一样的\nI:可以隔离多个并发事务,避免影响\nD:事务一旦提交成功,数据保证持久性*\n\n**<u>（反正记住一个原则，数据库肯定比经典存储优势多得多）</u>**\n\n------\n\n## 主流产品剖析\n\n### 单机存储\n\n#### 概览OwO\n\n> 单机存储 = 单个计算机节点上的存储软件系统，一般不涉及网络交互。一般分为：**<u>本地存储系统</u>        <u>key-value存储</u>**\n\n接下来我们先介绍一下~~单机~~本地文件系统\n\nLinux系统（~~应该没有人不知道吧~~）就是一个典型的本地文件系统，正如Linux经典哲学所说：**一切皆文件**\n\n文件系统的管理单元就是**文件**\n\n文件系统接口：文件系统很多种，比如说rootfs，sysfs，Ext2/3/4等等，但这些都遵循VFS（虚拟文件系统，是Linux内核的子系统之一）的统一抽象接口\n\nLinux文件系统的两大数据结构：**Index Node** & **Directory Entry**\n\n| Index Node                                   | Directory Entry                                        |\n| -------------------------------------------- | :----------------------------------------------------- |\n| 记录文件元数据，如id、大小、权限、磁盘位置等 | 记录文件名、inode指针，层级关系（parent）等            |\n| inode是一个文件的唯一标识，会被存储到磁盘上  | dentry是内存结构，与inode的关系是N:1（hardlink的实现） |\n| inode的总数在 格式化文件系统时就固定了       |                                                        |\n\n### key-value存储\n\n> 世间一切皆***key-value***——key是你的身份证，value是你的内涵\\(￣︶￣*\\))\n\n常见使用方式：put(k,v)&get(k)\n\n常见数据结构：LSM-Tree,某种程度上牺牲读性能，追求写入性能\n\n拳头产品：RocksDB\n\n![这是一张原理示意图](/assets/post_img/存储与数据库/3.png)\n\n（左边是内存，右边是磁盘）\n\n左边内存里黄色的MemTable满了以后就会被刷到下面灰色的Immutable MemTable（不可变），之后过一段时间或者条件触发，它就会把这个东西的顺序写入到磁盘中的SSTable（有序的key-value集合）里面，当Level 0装满以后，数据就会被下刷到Level 1，再满就会被下刷到Level 2，最终如果要读取一个最新版本的key-value数据，它可能就需要合并多层的0，1，2或者更多层的里面的key-value数据来得到一个最新版本，它才能服务用户的get请求（~~好复杂~~）\n\n### 分布式存储\n\n#### 概览UwU\n\n分布式存储 = 在单机存储基础上实现了*分布式协议*，涉及大量网络交互\n\n- #### HDFS\n\nHDFS堪称大数据时代的基石\n\n在HDFS诞生之前，市面的专用高级硬件很贵，同时数据存量很大，要求超高的吞吐，所以HDFS应运而生\n\nHDFS的特点正是解决了这几点：\n\n- 支持海量存储\n- 高容错性\n- 弱POSIX语义\n- 使用普遍x86服务器，性价比高\n\n>  其实HDFS的原理可以理解为多个低配硬件协作存储，既保证了存储又降低了成本，性价比很高\n\n下面是一个HDFS架构图（具象一下基本原理）\n\n![111](/assets/post_img/存储与数据库/4.png)\n\nManagement Node就是分布式系统的管控面\n\n- #### Ceph\n\n Ceph可是开源分布式存储系统里面的【万金油】\n\n- 而Ceph的核心特点便是：\n  一套系统支持对象接口、块接口、文件接口，但是一切皆对象\n- 数据写入采用主备复制模型\n- 数据分布模型（没错，又是平分，这次是数据）采用CRUSH算法（HASH+权重+随机抽签）\n\n![演示](/assets/post_img/存储与数据库/5.png)\n\n------\n\n\n\n## 单机数据库\n\n### 概览\n\n单机数据库 = 单个计算机节点上的数据库系统\n\n事务在单机内执行，也可以通过网络交互实现分布式事务\n\n### 关系型数据库\n\n商业产品Pracle称王，开源产品 MySQL&PostgreSQL\n\n#### MySQL（小海豚logo）\n\n关系型数据库的通用组件：\n\n- Query Engine——负责解析query，生成查询计划\n- Txn Manager——负责事务并发管理\n- Lock Manager——负责锁相关的策略\n- Storage Engine——负责组织内存/磁盘数据结构\n- Replicatioin——负责主备同步\n\n#### PostgreSQL（大象logo）\n\n- 关键内存数据结构：B-Tree、B+-Tree、LRU List等\n- 关键磁盘数据结构：WriteAheadLog （RedoLog）、Page\n\n![演示](/assets/post_img/存储与数据库/6.png)\n\n### 非关系型数据库\n\n> MongoDB、Redis、Elasticsearch三足鼎立\n\n关系型数据库一般直接使用SQL交互，而非关系型数据库交互方式各不相同\n\n非关系型数据库的数据结构千奇百怪，没有关系约束后，schema相对灵活\n\n不管是否关系型数据库，大家都在尝试支持SQL（子集）和“事务”\n\n![演示](/assets/post_img/存储与数据库/7.png)\n\n### Elasticsearch使用案例\n\n![演示](/assets/post_img/存储与数据库/8.png)\n\n跟RDBMS相比，ES天然能做【模糊搜索】，还能自动算出关联程度\n\n------\n\n\n\n## 从单机到分布式数据库\n\n单机数据库遇到了哪些问题 & 挑战，需要我们引入分布式架构来解决？？\n\n答案是容量，弹性和性价比\n\n### 解决容量问题\n\n![演示](/assets/post_img/存储与数据库/9.png)\n\n### 解决弹性问题\n\n![演示](/assets/post_img/存储与数据库/10.png)\n\n### 其它要做的\n\n除了解决容量以及弹性问题之外，还有一些问题等着我们去优化解决：\n\n- 单写vs多写\n- 从磁盘弹性到内存弹性\n- 分布式事务优化\n\n  ------\n\n  \n\n## 新技术演进\n\n### 概览\n\n|    新技术    |                   例子                   |\n| :----------: | :--------------------------------------: |\n| 软件架构变更 |             Bypass OS kernel             |\n|    AI增强    |             智能存储格式转换             |\n|  新硬件革命  | 存储介质变更，计算单元变更，网络硬件变更 |\n\n### SPDK\n\n> Bypass OS kernel已经成为一种趋势\n\nSPDK（Storage Performance Development Kit）带来的三个优势：\n\nKernel Space → User Space\n\n- 避免syscall带来的性能损耗，直接从用户态访问磁盘\n\n中断 → 轮询\n\n- 磁盘性能提高后，中断次数随之上升，不利于IO性能\n- SPDK poller可以绑定特定的cpu核不断轮询，减少cs，提高性能\n\n无锁数据结构\n\n- 使用Lock-tree queue，降低并发时的同步开销\n\n### AI & Storage\n\nAI领域相关技术，如Machine Learning在很多领域：如推荐、风控、视觉领域证明了有效性\n\n在Storage领域，AI能给我们带来什么呢？\n\n逻辑上看到的数据组织格式有行存和列存（表里面有多个行和列），但是在经过AI决策之后，可以实现行列混存，更好适应动态性比较强的业务\n\n### 高性能硬件\n\n1.RDMA网络\n\n- 传统的网络协议栈，需要基于多层网络协议处理数据包，存在用户态 & 内核态的切换，足够通用但性能不是最佳\n- RDMA是kernel bypass的流派，不经过传统的网络协议栈，可以把用户态虚拟内存映射给网卡，减少拷贝开销，减少cpu开销\n\n2.Persistent Memory\n\n在NVMe SSD和Main Memory间有一种全新的存储产品：Persistent Memory\n\n- IO时延介于SSD和Memory之间，约百纳秒量级\n- 可以用作易失性内存（Memory mode），也可以用作持久化介质（app-direct）\n\n3.可编程交换机\n\nP4 Switch，配有编译器、计算单元、DRAM，可以在交换机层对网络包做计算逻辑，在数据库场景下，可以实现缓存一致性协议等\n\n4.CPU/GPU/DPU\n\n- CPU：从multi-core走向many-core\n\n- GPU：强大的算力 & 越来越大的量存空间\n\n- DPU：异构计算，减轻CPU的workload\n\n  ------\n\n  \n\n## 总结\n\n### 存储系统\n\n- 块存储：存储软件栈里的底层系统，接口过于朴素\n- 文件存储：日常使用最广泛的存储系统，接口十分友好，实现五花八门\n- 对象存储： 共有云上的王牌产品，immutable语义加持\n- key-value存储：形式最灵活，存在大量的开源/黑盒产品\n\n### 数据库系统\n\n- 关系型数据库：基于关系和关系代数构建，一般支持事务和SQL访问，使用体验友好的存储产品\n- 非关系型数据库：结构灵活，访问方式灵活，针对不同场景有不同的针对性产品\n\n### 分布式架构\n\n- 数据分布策略：决定了数据怎么分布到集群里的多个物理节点，是否均匀，是否能做到高性能\n- 数据复制协议：影响IO路径的性能、机器故障场景的处理方式\n- 分布式事务算法：多个数据库节点协同保障一个事务的ACID特性的算法，通常基于2pc的思想设计\n\n\n\n> ***THE END~~***\n","tags":["数据库"],"categories":["数据库"]},{"title":"计算机基础(1)——进制转换与表示，原码、反码、补码","url":"/2024/11/10/计算机基础(1)——进制转换与表示，原码、反码、补码/","content":"\n# 计算机基础(1)——进制转换与表示，原码、反码、补码\n\n## 进制转换\n### 不同进制用来表示数字的符号\n\n| 进制     | 符号                                           |\n| -------- | ---------------------------------------------- |\n| 二进制   | 0  1                                           |\n| 八进制   | 0  1  2  3  4  5  6  7                         |\n| 十进制   | 0  1  2  3  4  5  6  7  8  9  10               |\n| 十六进制 | 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F |\n\n几进制就是满几进一\n\n其中十六进制的 A ~ F 在十进制代表的是10 ~ 15，因为要用一个符号代替，所以用了字母\n\n### 任意进制与十进制\n\n#### 任意进制—>十进制\n\n假设进制数是x\n\n任意进制转换十进制的算法为：从右往左数第n位乘x的n-1次幂然后加起来，下面计算是原式从左往右算，手算的话从右往左写幂数更不容易错\n\n比如说十进制数567，可以表示成：\n$$\n5*10^2 + 6*10^1 + 7*10^0\n$$\n二进制1010101转十进制，计算方式为\n$$\n1*2^6+0*2^5+1*2^4+0*2^3+1*2^2+0*2^1+1*2^0=85\n$$\n八进制13105640转十进制，计算方式为\n$$\n1*8^7+3*8^6+1*8^5+0*8^4+5*8^3+6*8^2+4*8^1+0*8^0=2919328\n$$\n十六进制同理，任意进制都可以这么算\n\n#### 十进制—>其他进制\n\n用十进制数除进制数x得到商和余数，商继续除x得到新的商和余数，继续下去直到商为0，得到的余数就可以组合成对应进制数\n\n十进制数50转二进制\n```tex\n50÷2，商25余0\n25÷2，商12余1\n12÷2，商 6余0\n 6÷2，商 3余0\n 3÷2，商 1余1\n 1÷2，商 0余1\t<-商为0，停止\n\n现在从上到下得到余数010011，实际上的二进制要从下往上倒过来，是110010\n所以十进制50的二进制是110010\n```\n\n十进制数50转八进制\n\n```tex\n50÷8，商6余2\n 6÷8，商0余6\t<-商为0，停止\n \n现在从上到下得到余数26，实际上的八进制要从下往上倒过来，是62\n所以十进制50的八进制是62\n```\n\n十进制数2717转十六进制\n\n```tex\n2717÷16，商169余13，13对应十六进制为D\n 169÷16，商 10余9\n  10÷16，商  0余10，10对应十六进制为A\t<-商为0，停止\n  \n现在从上到下得到余数D9A，实际上的十六进制要从下往上倒过来，是A9D\n所以十进制50的十六进制是A9D\n```\n\n### 其他进制转换\n\n~~实在不会一步转换就用十进制做跳板罢~~\n\n#### 二进制与八进制\n\n##### 二进制—>八进制\n\n$$\n2^3=8\n$$\n\n因为2和8的幂次关系，从右往左数每3位二进制可以找转换为一个八进制字符，最后不够的可以补0\n\n二进制 10111001 转八进制：\n```tex\n首先将 10111001 每三个划分一组\n10  111  001\n然后对每组分别计算\n```\n\n对 10 计算：\n$$\n1*2^1 +0*2^0=2\n$$\n对 111 计算：\n$$\n1*2^2+1*2^1 +1*2^0=7\n$$\n对 001 计算：\n$$\n0*2^2+0*2^1+1*2^0=1\n$$\n组合起来八进制就是271\n\n二进制 10111001 转八进制为 271\n\n##### 八进制—>二进制\n\n将八进制数的每一位用三个二进制符号表示即可，这里单个数字可以用十进制转二进制时的算法\n八进制数512转二进制：\n```tex\n5 —> 5连除2得到余数逆序为101\n1 —> 1连除2得到余数逆序为01，补0至三位即为001\n2 —> 2连除2得到余数逆序为10，补0为010\n\n二进制即为101001010\n```\n\n\n\n#### 二进制与十六进制\n\n##### 二进制—>十六进制\n\n$$\n2^4=16\n$$\n因为2和16的幂次关系，从右往左数每4位二进制可以找转换为一个十六进制字符，最后不够的可以补0\n\n计算过程和二进制转八进制非常相似\n\n二进制 10111001 转十六进制：\n```tex\n首先将 10111001 每四个划分一组\n1011  1001\n然后对每组分别计算\n```\n\n$$\n1*2^3+0*2^2+1*2^1+1*2^0=11（B）\n$$\n\n$$\n1*2^3+0*2^2+0*2^1+1*2^0=9\n$$\n\n二进制 10111001 转十六进制为 B9\n\n##### 十六进制—>二进制\n\n类比八进制转二进制，十六进制每个字符要用四个二进制数表示\n\n十六进制B9A转二进制\n```tex\nB —> 11连除2，得到余数逆序1011\n9 —> 9连除2，得到余数逆序1001\nA —> 10连除2，得到余数逆序1010\n\n二进制即为101110011010\n```\n\n\n\n#### 八进制和十六进制\n\n用二进制或者十进制做桥梁\n\n\n\n## 原码、反码、补码\n\n计算机通常使用二进制，原码、反码、补码是计算机中对的二进制表示方法\n\n> 原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。\n>\n> 反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。\n>\n> 补码：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。\n>\n> 正数的原码、反码、补码完全一样，只有负数需要按照以上规则计算\n\n### 原码（Sign-Magnitude）\n\n原码是最简单的表示有符号整数的方式。它的规则很简单，即使用二进制表示数值的绝对值，最高位表示符号位（0表示正数，1表示负数）。例如，+5的原码为00000101，-5的原码为10000101。\n\n原码的优点是直观简单，符号位可以直接判断正负。但是原码存在加减法运算时出现的溢出问题。\n\n> 扩展：原码为什么会有溢出问题\n>\n> 1. 符号位干扰。两个正数相加可能会因为进位问题导致符号位变化，从而产生错误的负数结果。\n>\n>    比如5的原码为0101，3的原码为0011，十进制相加后十进制为8，而二进制为1000，对应十进制为-8\n>\n> 2. 表示范围有限。对于n位二进制数，能够表示的范围是-（2^(n-1)-1）到2^(n-1)-1。如果运算结果超出这个范围，就会发生溢出。\n\n\n\n### 反码（One's Complement）\n\n为了解决原码的溢出问题，反码被提出。反码的规则是：正数的反码与原码相同，负数的反码是对该数的原码按位取反，将原码中的0变为1，1变为0。\n\n例如，+5的反码仍为00000101，-5的反码为11111010。\n\n反码解决了原码运算溢出的问题，但是存在“0”的两个表示（正0和负0），并且减法运算仍然存在一些问题。\n\n> 扩展：反码的减法问题\n>\n> 主要问题在于**零的表示不唯一**。在反码表示法中，零有两种表示形式：正零（所有位为0）和负零（符号位为1，其余位为0）\n>\n> -5的反码为11111010，7的反码为00000111，7-5也就是7+(-5)，得到的二进制结果是00000001（+1）\n>\n> 因为反码中+0是0000000表示的，-0是11111111表示的，-0变为+0需要一个1，所以导致运算结果错误\n\n\n\n### 补码（Two's Complement）\n\n为了进一步解决反码的问题，补码被引入。补码的规则是：正数的补码与原码相同，负数的补码是对该数的反码加1，这一步解决了反码中少1的问题。\n\n例如，+5的补码仍为00000101，-5的补码为11111011。\n\n### 总结\n\n通常使用补码来表示二进制负数，结合上述，表示二进制负数方法为：**绝对值按位取反(每一位1变0，0变1)后最后一位加1**\n\n\n\n## 扩展内容\n\n### 关于进制转换\n\n小trick：windows计算器中的程序员模式能快速计算不同进制\n\n也有很多在线工具能够快速计算 [进制转换 - 在线工具](https://tool.lu/hexconvert/)\n\n### EXP（C++，二、八、十、十六进制转换）\n\n输入格式：代转换数 当前进制 目标进制\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nlong long to10(string s,int k){\n\tlong long ans=0,d=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]>='A') ans=ans*k+(s[i]-'A'+10);\n\t\telse ans=ans*k+(s[i]-'0');\n\t\td++;\n\t}\n\treturn ans;\n}\nstring from10(long long n,int k){\n\tif(n==0) return \"0\";\n\tstring b=\"0123456789ABCDEF\",ans;\n\twhile(n>0){\n\t\tans+=b[n%k];\n\t\tn/=k;\n\t}\n\treverse(ans.begin(),ans.end());\n\treturn ans;\n}\nint main() {\n    int b,d;\n    string s;\n    cin>>s>>b>>d;\n    cout<<from10(to10(s,b),d);\n    return 0;\n}\n```\n\n","tags":["计算机基础"],"categories":["计算机基础"]},{"title":"从0 → ∞ 成为 Minecraft JE腐竹","url":"/2024/10/13/从0 → ∞ 成为 Minecraft JE腐竹/","content":"\n# 从 0 → ∞ 成为 Minecraft JE 腐竹\n\n> 本文写于 2024.10.13 ，技术与时俱进，但是基础永恒不变。——顾白\n\n## 前言\n\nMinecraft 至今已经有 15 个年头了，15 年内优秀服务器不断涌现。已经 2024 年了，mc 服务器门槛已经相当的低。网络上虽然各种资料都有，但质量参差不齐。这篇教程将从头到尾介绍创建 mc java 服务器所有基础流程，以及我对 mc 服务器的一些看法。所以这篇教程会非常长~~而且没有图片~~。\n\n> 注意：不是所有联机情况都需要开服。如果只是一两个人联机，或者宿舍一起玩，那么局域网联机、联机 mod、内网穿透等联机方式就完全足够了\n\n> 阅读本篇教程你需要准备的是：\n>\n> 1. 能分辨问题的脑子，没断掉的且能自由活动的手，能感知光照的眼睛\n> 2. 能联网的电脑\n> 3. 一款好用的浏览器，推荐谷歌、edge\n> 4. 会解压，有一款能用来解压的软件，比如 7-zip 等等\n> 5. 打开隐藏目录和文件扩展名显示\n> 6. 一款趁手的文本编辑器，如 vscode 等等\n> 7. 初中英语水平，以及能够上网找翻译的能力\n> 8. 不奢求开服赚米回本、敢于试错的心态\n> 9. 敢于自主解决问题的心态\n> 10. 耐心\n> 11. 钱\n\n基础教程基本不涉及 java 编程，其实大多数服主都没有编程基础。如果只是开个基友服，看完本篇教程绰绰有余\n\n在开始之前，还是要说，这篇教程着重教的不是固定模板开服，那会失去自主探索的能力；也不是教某个 mod 或者插件具体怎么用，因为优质教程贴数不胜数。如果只是想找个整合包一键无脑开，那还请选择其他教程。\n\n> 授人以鱼不如授人以渔\n\n---\n\n## 基础教程\n\n### 准备工作\n\n#### java 环境\n\n[Java Downloads](https://www.oracle.com/java/technologies/downloads/)\n\n首先要明确的是，mc java 版是使用 java 语言开发的，java 版服务器也是基于 java 的。至于 java 语言是什么，零基础者只需要知道这是一个能跨平台(win、linux、mac os 等等)的编程语言即可。\n\n既然是 java 语言开发的，那么就要配置一下 java 环境，不然有关 java 的都无法运行。\n\n下面是 mc 各个版本对应的 java 版本。\n\n| mc 版本             | java 版本 |\n| ------------------- | --------- |\n| 1.12(17w13a)开始    | java 8    |\n| 1.17(21w19a)开始    | java 16   |\n| 1.18(1.18-pre2)开始 | java 17   |\n| 1.20.5(24w14a)开始  | java 21   |\n\n根据想要开的服务器的版本选择 java 环境。\n\n假设这里要开一个 1.21 的服务器，那么就需要下载 JDK 21。要开 1.12 的服务器，就需要 JDK 8\n\n> 这里可能会有疑惑，为什么我要把 java 写为 JDK，这涉及到 java 的几个版本问题。\n>\n> 实际上，Java 是一种编程语言，而 JDK（Java Development Kit）是用于开发 Java 应用程序的一套工具。\n>\n> 也许有了解过 java 的同学想问，为什么不安装 JRE。这就涉及到 JRE 和 JDK 的区别了\n>\n> JDK 包括了编译器（javac）、解释器（java）、调试器（jdb）、文档生成工具（javadoc）等开发工具，以及 Java 运行环境（JRE）和 Java 基础类库（Java API）。\n>\n> JRE 中包含了 Java 虚拟机（JVM）和 Java 标准类库，是运行 Java 程序所必需的环境。\n>\n> 换句话说，JDK 是 JRE plus，JRE 能实现的功能，JDK 都能实现。JRE 没有的功能 ，JDK 也能实现。如果有想要从事 Java 开发的同学，JDK 是刚需。所以果断装全面的，避免以后出现各种麻烦。\n\n注意：同一电脑可以安装多个版本 java。\n\n**安装 java 过程要注意安装路径！一定要记住！**\n\n下载有两种方案\n\n1. 下载 exe 安装包，常规安装\n2. 下载 zip 压缩包，压缩包 **解压** 后包含所有安装内容\n\n两者实际上都可以。压缩包方便拷贝但是没有注册表，安装包一键安装有注册表。如果使用压缩包版本，一定要**完整解压**再使用！\n\n在**windows**下安装完 JDK 后还需要配置环境变量，使终端能在任何位置下都能检测到 java。也可以不配置环境变量，但是需要在服务器启动程序中标注 java 路径。[java 环境配置(详细教程)\\_java 环境配置-CSDN 博客](https://blog.csdn.net/xhmico/article/details/122390181)\n\n至于**linux**，可以参考这篇教程[Linux 配置 Java 环境（图文详细）\\_⑤ 配置 java 运行环境 linux-CSDN 博客](https://blog.csdn.net/weixin_43520670/article/details/106344655)\n\n至于**Mac OS**，可以参考这篇教程[超详细的 Java 安装教程（Mac 版）\\_mac 安装 java-CSDN 博客](https://blog.csdn.net/weixin_61536532/article/details/126791735)\n\n~~linux 比 windows 优化好多了，为什么不用 linux 开服呢？因为我当初不会 linux~~\n\n至此你已经完成了 1/4\n\n---\n\n#### 选择一个合适的服务器核心\n\n推荐镜像站：[FastMirror.](https://www.fastmirror.net/#/download/)(镜像站没有 fabric 核心)\n\n服务器不会被 java 自己生出来的。\n\n> 什么是服务器核心？\n>\n> 服务端核心(简称核心，有时也被叫做服务端)是指开服时用于直接或间接启动 Minecraft 服务器的一类文件，文件名一般以 .jar 结尾。\n>\n> 换句话说，没有核心，就没有服务器\n\n选择一个合适自己的核心是很重要的。\n\n目前服务器模式有：\n\n1. 官服，纯原版，只支持数据包，这种属于官方核心：vanilla 核心(也被称为香草、官核)\n2. 纯 fabric / forge 模组服\n3. forge + spigot 混合服\n4. 插件服\n\n下面逐一介绍每个模式对应的核心\n\n> 官服：bugjiang(mojang)发布的服务端，不支持 mod 和插件，支持数据包 [下载官核](https://www.minecraft.net/zh-hans/download/server)\n\n> 纯 fabric 端：生电首选，保留了绝大部分原版特性。能安装 fabric mod 以及数据包，不支持插件和 forge mod。兼容性非常好。[Download Minecraft Server Launcher | Fabric (fabricmc.net)](https://fabricmc.net/use/server/)\n\n> 纯 forge 端：整合包首选，修复了部分原版特性。能安装 forge mod 和数据包，不兼容 fabric mod。兼容性较差。[Downloads for Minecraft Forge for Minecraft 1.16.5](https://files.minecraftforge.net/net/minecraftforge/forge/index_1.16.5.html)\n\n> forge + spigot 混合服：既能装 forge mod，又能装 spigot 插件，虽然五脏俱全但是兼容性更差了，崩服、forge mod 不兼容是常见的事\n\n> 插件服：只能装插件，技术难度无上限。好处是没有了 mod 莫名其妙报错的干扰，容易确定报错点，也没有 mod 服不能随便卸 mod 的困扰。插件服核心种类丰富，如一家独大的 Paper 以及一些分支，老牌 spigot。不同插件服有不同的优势。\n>\n> paper：优化很好，修复了很多特性，性能更强，支持的插件极为丰富。更新速度比 spigot 慢几个小时或者几天。\n>\n> folia(paper 分支)：paper 团队新产品，为数不多支持多线程的服务器，配置后生电限制少，插件库正在发展，未来可期。\n>\n> purpur：做了大量优化，可以通过配置选择性打开生电选项，插件丰富，插件生电服首选。\n>\n> spigot：优化略微逊色，特性修复较少(不足以生电)，支持的插件极为丰富，更新速度非常快，新版本发布后几个小时内就能用上 spigot。\n>\n> 还有很多很多核心。但这几款以及足够新手腐竹用了。\n>\n> 插件服发展史放到后面说。\n\n现在，新建文件夹，将你的核心 .jar 文件放进去，就到达了新世界的门口\n\n---\n\n#### 编写启动脚本\n\n\n为什么要编写脚本？主要是给 java 提供参数设置，给 java 一些设置，让 java 的运行符合预期。\n\n如何编写？在**windows**下，需要新建文本文件，在文件内填入以下内容后将文件后缀的 txt 改为 bat。在**linux**下，需要新建.sh 文件，填入的内容需要去掉 `@ECHO OFF` 和 `pause`，其他内容相同。\n\n这是一个最简单的启动程序。\n\n```bash\n\"C:\\Program Files\\Java\\jdk1.8.0_301\\bin\\java\" -jar server.jar\npause\n```\n\n看不懂没关系，下面对这些内容逐一解释\n\n首先是最开始引号内的路径，这是指定 java 路径的语句，如果没有配置环境变量，或者是想要指定这个服务器用哪个版本的 java，就可以用这个语句来指定 java。这个路径可以是绝对路径，也可以是相对路径。如果配置好了环境变量，连同引号在内所有内容都可以用 java 代替，比如：\n\n```bash\njava -jar server.jar\npause\n```\n\n然后是 `-jar` ，作用是启动 jar 文件(在这里就是指服务器核心)，后面的 server.jar 是指定的核心名。\n\n然后是 `pause` ，代指程序暂停，这是一个系统命令，与 java 无关。这个命令最大的用处在于，他会让终端在服务器关闭后不会直接消失，这样会很方便查看崩服的原因，不然只能看日志了。\n\n这是一个最简单的启动示例，还有各种各样的启动参数，比如 `-Xms` `Xmx` `Xincgc` 等等，下面是一个很常见的启动参数，相比上面的参数，增加了内存控制\n\n```base\njava -Xms1G -Xmx4G -jar server.jar\npause\n```\n\n> **-Xmx**：最大内存，默认为物理内存的 1/4 或者 1G，必须大于 2M，可以指定单位 k(K),m(M),g(G)\n>\n> **-Xms**：初始化内存大小(可以理解为最小内存大小)，默认为物理内存的 1/64，需大于 1M，单位上同\n>\n> **-Xincgc**：开启增量 GC[垃圾收集(Garbage Collection)通常被称为 “GC”]；这有助于减少长时间 GC 时应用程序出现的停顿。但可能会降低 CPU 对应用的处理能力。\n>\n> 对于 forge mod 服(包括 sponge)，建议将-Xmx 和-Xms 设为同值\n\n下面是推荐的启动脚本(具体内存数按需更改，分配的内存不要过少)\n\n纯净：\n\n```bash\n@ECHO OFF\njava -server -Xms4g -Xmx8g -XX:+AggressiveOpts -XX:+UseFastAccessorMethods -XX:+UseG1GC -XX:SurvivorRatio=6 -XX:G1ReservePercent=15 -XX:ParallelGCThreads=4 -XX:ConcGCThreads=1 -XX:InitiatingHeapOccupancyPercent=40 -jar 核心名.jar\npause\n```\n\nmod：\n\n```bash\n@ECHO OFF\njava -server -Xms8g -Xmx8g -XX:+AggressiveOpts -XX:+UseFastAccessorMethods -XX:+UseG1GC -XX:SurvivorRatio=6 -XX:G1ReservePercent=15 -XX:ParallelGCThreads=4 -XX:ConcGCThreads=1 -XX:InitiatingHeapOccupancyPercent=40 -jar 核心名.jar\npause\n```\n\n这样就完成了启动脚本的编写。启动脚本需要放到核心同级目录里（也就是在一个文件夹内既要看到核心，又要看到启动脚本）\n\n---\n\n### 启动\n\n#### EULA\n\n一切准备就绪，windows 下直接双击启动脚本，linux 下使用指令运行.sh 文件\n\n如果一切是从头开始且没有报错的话，不出意外，你的程序会暂停。\n\n这是因为你需要同意 EULA 协议，你可以在终端看到 EULA 提示。\n\n> **[Minecraft® EULA 协议](https://link.zhihu.com/?target=https%3A//account.mojang.com/documents/minecraft_eula)**，官方网址 [https://account.mojang.com/documents/minecraft_eula](https://link.zhihu.com/?target=https%3A//account.mojang.com/documents/minecraft_eula)。其 EULA 协议本质上就是 Minecraft 的发行工作室 Mojang AB 对于 Minecraft 所有用户的一个使用协议。\n\n在服务器文件夹可以看到有个名为 eula.txt 的文件，打开后将 false 改为 true，就代表你同意了协议，然后再次打开服务器即可。~~没人会憨到改为 true 后把这个文件删掉吧~~\n\n虽然这是一个无关紧要的必须同意协议，但是我希望所有服主都认认真真看一遍。在最后也会谈到这个问题。\n\n#### 服务器结构\n\n在终端看到 `Done` 时，代表服务器启动完毕。在这过程中服务器会自动补全所有必要的文件。\n\n不同服务器核心，结构略微有所区别。下面是官核结构\n\n```\n服务器文件夹\n├─crash-reports \t\t//崩溃报告\n├─logs \t\t\t\t\t//日志，存储终端所有内容\n├─world \t\t\t\t//地图文件\n├─banned-ips.json\t\t//被ban的ip列表\n├─banned-players.json\t//被ban的玩家\n├─eula.txt\t\t\t\t//EULA协议\n├─server.jar\t\t\t//服务器核心\n├─ops.json\t\t\t\t//op以及op等级列表\n├─server.properties\t\t//服务器配置文件\n├─usercache\t\t\t\t//玩家id、uid、最近一次入服的记录\n├─whitelist\t\t\t\t//白名单列表\n├─启动脚本\n```\n\n其他核心结构与官核大差不差，比如 mod 服会多出一个 mods 文件夹，插件服会多出一个 plugins 文件夹，混合服则多出上述两种文件夹。\n\n##### logs 和 crash-reports\n\n用于记录服务器日志和崩溃原因。这是日后对服务器崩溃进行处理、寻找崩溃原因、抓熊孩子等等重要取证文件。\n\n如果在这些目录中发现了.tar.gz 格式，这是压缩格式的一种，用解压软件打开即可。\n\n##### 地图结构\n\n地图结构在不同服务器核心会有变化。如果使用 paper 核心，会发现还有 `world_nether` `world_the_end` 两个文件夹，分别代表地狱和末地文件夹。而 world 文件夹相比其他核心，少了 `DIM1` 和 `DIM-1` 文件夹。\n\n这是核心对地图结构的改变，DIM1 相当于 world_the_end，DIM-1 相当于 world_nether。\n\n如果后续使用了多地图插件，或者是能生成更多维度世界的 mod，在两种地图结构中会发现，生成的地图(假设名为 DIM3)位置也不同，在类似于 paper 一样的地图结构中，会生成在 world 文件夹外面，和 world、world_nether、world_the_end 并列；在类似于原版的地图结构中，DIM3 会生成在 world 文件夹内，和 DIM1、DIM-1 并列，被 world 文件夹包含\n\n如果想要在两种地图结构中互相改变，只需要将文件夹重命名后放到对应结构位置即可。\n\n###### 更改服务器地图\n\n如果想将预设地图放到服务器内，首先要按照服务器地图结构将原地图进行结构变化\n\n结构变化后，将服务器关闭，删除现有服务器地图，将预设地图拷贝进来即可\n\n需要注意的是，如果一些插件强制规定了进入服务器时的位置，需要及时更改这个设置。常规方法是先记住预设坐标，在服务器中 tp 到坐标位置，然后将强制规定的进入服务器时的位置在游戏内用指令更改为这个坐标；或者是直接修改插件配置文件。\n\n##### mods / plugins\n\n用于安装 mod 和插件的文件夹，将需要安装的.jar 文件直接拖入即可。\n\n###### mod\n\n要注意模组加载器是否匹配，游戏版本是否匹配，是否有冲突，是否缺少前置。forge 模组报错首先搜一下报错内容，或者全部复制下来问 ai。没用解决方案的话就需要联系模组作者了。\n\n**下载 mod 推荐[mcmod](https://www.mcmod.cn/download/)、[CurseForge](https://www.curseforge.com/)、[Modrinth](https://modrinth.com/)**\n\n###### plugin\n\n同 mod 要求。插件一般情况下会在 plugins 文件夹生成一个以插件名命名的文件夹，里面存放插件各种配置文件。这些配置文件需要按照插件文档进行修改。可以在后台使用指令 `plugins` 查看插件情况。\n\n**下载插件推荐[SpigotMC](https://www.spigotmc.org/)、[CurseForge](https://www.curseforge.com/)**\n\n##### server.properties 详解\n\n> **server.properties**是储存多人游戏（Minecraft 或 Minecraft Classic）服务器所有设置的文件。\n>\n> 在编辑 server.properties 时，行之间的顺序可以打乱，但文件结构不能改变。每一行的等号之前的文本为变量名，你不应该修改这些内容。等号后面为变量的值，你可以按照规则自行编辑。以`#`开头的行为注释，添加、修改或移除注释行不会对游戏造成影响。\n>\n> 保存了 server.properties 的更改之后，服务端必须重启才能使更改生效，另一种选择是在服务器后台或游戏中使用`/reload`命令重新加载，但有时候会产生卡顿。\n>\n> 如果 server.properties 文件未列出一些属性（例如服务端版本更新加入新属性，或该文件还未创建），那么服务器在启动时会重写 server.properties 补全缺失的属性，并将缺失的属性值设为默认值。\n>\n> 尽管有扩展名，server.properties 文件只是一个普通的 UTF-8 编码文本文件，因此可以使用任何文本编辑器进行编辑，比如 Windows 上的记事本、macOS 上的 TextEdit 或者 Linux 上的 nano 和 vim。\n\n下面是 server.properties 配置文件的重要部分的注释，还有一部分翻译一下就出来了~~(blog 好像炸了)~~\n\n```text\n#Minecraft server properties\n#（文件修改时间戳）\nenable-jmx-monitoring=false\nrcon.port=25575\nlevel-seed=\t\t\t// 地图种子，空为随机\ngamemode=survival\t\t\t// 默认游戏模式，可能被其他插件/mod取代\nenable-command-block=false\t\t\t// 是否启用命令方块\nenable-query=false\ngenerator-settings={}\nenforce-secure-profile=false\t\t\t// 强制安全验证\nlevel-name=world\t\t\t// 主世界地图文件夹名\nmotd=A Minecraft Server\t\t\t// motd文本，没啥用，很鸡肋，可以被mod/插件取代\nquery.port=25565\npvp=true\t\t\t// 是否启用pvp，也可以被mod/插件取代\ngenerate-structures=true\t\t\t// 是否生成结构\nmax-chained-neighbor-updates=1000000\ndifficulty=easy\t\t\t// 游戏难度\nnetwork-compression-threshold=256\nmax-tick-time=60000\t\t\t// 最大延迟\nrequire-resource-pack=false\t\t\t// 是否需要资源包\nuse-native-transport=true\nmax-players=20\t\t\t// 最大玩家数(鸡肋，没用)\nonline-mode=false\t\t\t// 是否开启正版验证\nenable-status=true\nallow-flight=false\t\t\t// 是否允许飞行(用来防飞行挂的，但是会防生存使用飞行类mod)\ninitial-disabled-packs=\nbroadcast-rcon-to-ops=true\nview-distance=10\t\t\t\t// 最大视距\nserver-ip=\nresource-pack-prompt=\nallow-nether=true\t\t\t// 是否生成地狱(false的话将不会加载地狱，也无法进入)\nserver-port=25565\t\t\t// 服务器端口\nenable-rcon=false\nsync-chunk-writes=true\nop-permission-level=4\t\t\t// op等级权限\nprevent-proxy-connections=false\nhide-online-players=false\nresource-pack=\t\t\t// 资源包链接\nentity-broadcast-range-percentage=100\nsimulation-distance=10\nrcon.password=\nplayer-idle-timeout=0\nforce-gamemode=false\nrate-limit=0\nhardcore=false\nwhite-list=false\t\t\t// 是否启用白名单\nbroadcast-console-to-ops=true\nspawn-npcs=true\nspawn-animals=true\nlog-ips=true\nfunction-permission-level=2\ninitial-enabled-packs=vanilla\nlevel-type=minecraft\\:normal\ntext-filtering-config=\nspawn-monsters=true\nenforce-whitelist=false\nspawn-protection=16\nresource-pack-sha1=\nmax-world-size=29999984\n```\n\n也可以参考这篇文章[Minecraft 服务器 server.properties 属性文件介绍 (最详细 最全 汉化) - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv7149916/)\n\n#### 控制台指令和重要指令\n\n后台使用指令时候，在原版指令的基础上，去掉了最开始的 `/`\n\n比如，`/gamemode` 在后台只需要 `gamemode`\n\n如果指令是双斜杠开头，比如 worldedit 中的 `//copy`，需要删掉一个 `/`，也就是在后台输入 `/copy` ~~(不过这个指令好像不能在后台执行)~~\n\n几个很重要的指令(这些指令游戏内也可以用，需要 op 权限)：\n\n1. `stop` 关服指令，尽量不要直接 x 掉或强制关闭进程，很可能回档、丢数据\n2. `reload` 重载指令，重新加载服务器配置文件以及数据包，但会产生卡顿\n3. `list` 列出所有在线玩家(包括 carpet 的假人)，这个指令也可以用来检测服务器是否正在运行\n4. `kick id` 踢出玩家，id 为玩家名\n5. `ban id` ban 掉玩家，id 为玩家名\n6. `ban-ip ip/id` ban 掉一个玩家所在的 ip，或直接 ban 掉某个 ip\n7. `pardon id` 解 ban 指令，id 为玩家名\n8. `pardon-ip ip` 解 ban 指令，ip 为有效地址\n9. `banlist` ban 列表\n10. `op id` 给玩家 op 权限，id 为玩家名\n11. `deop id` 撤掉 op 权限，id 为玩家名\n12. `plugins` 查看插件情况，绿色为正常，黄色为存在部分问题，红色为出现的问题影响正常功能，基本不能使用\n\n虽然控制台权限至高无上，但是有些指令不能在后台用(比如涉及插件的 gui 界面)\n\n---\n\n### 云服务器、物理机\n\n现在整个服务器运行在你的本地，如果想要一直开服，需要 24h 保持运行，这对大部分人来说是不可能的。那么如何解决这个问题呢，那就是云服务器 / 物理机了\n\n下面将云服务器称为机子，我的世界服务器称为服务器，一是方便区分，二是习惯称呼\n\n什么是机子？简单来说，就是远程电脑，这个电脑能保持开机状态，并且服务商提供了公网 ip 和端口让你能从外部连接到机子后台，还会提供一些开放端口让你能够进入服务器。\n\n#### 如何选择机子，配置怎么看\n\n选择机子三要素：稳定，价格，配置\n\n稳定性不用多说，谁都不希望玩着玩着突然机子关机了。当然，大多数服务商不会烂到这种地步。\n\n价格方面，配置越高，价格越高。阿里、华为、腾讯等等大厂的价格极高，在没有优惠的情况下不建议购买。小厂商推荐剑客云、蓝夜科技等。一般来说，一个服务商如果有浏览器控制机子后台的功能(并不是指浏览器控制 mc 服务器后台)，那么这个厂商就可以纳入考虑范围之内。~~因为实现这个功能很麻烦，跑路服务商才不会做~~\n\n配置方面，看服务器规模。配置几大要素分别是：cpu、内存、硬盘、宽带。\n\ncpu：mc 作为单核游戏，不用过多考虑服务器核心太少，只需要单核性能足够强大。当然，如果是 folia，可以选择降低单核性能，选择更多核心，这样可以利用 folia 多核心性质来降低成本。\n\n内存：2g 起步。生电服推荐 10g 左右，给服务器分 8g(再多点就更好了，8g 有点勉强)。如果是插件服或者模组服，按照插件和模组的多少进行调动。不要担心内存占用太高，内存就是拿来用的，除了系统运行需要外，空 1、2g 内存就是在浪费。\n\n硬盘：10g 起步，服务器开到后期会发现占用硬盘的大头不是插件和模组，而是地图。可以一开始选择较小硬盘，逐渐增加。适当时候开启新周目。\n\n宽带：1Mbps(M) = 128 kb/s。这个绝对是值得花钱的地方。如何估算呢？而一个用户，在不大规模加载地图时候，大概是消耗服务器带宽 20kb/s 左右。玩家加载地图时候的瞬时带宽可能会突破 200kb/s。所以，1M=2.5 人左右~~(有点诡异)~~，推荐 3M 起步。\n\n以上都是云服务器需求，如果物理机，考虑因素更多了。~~物理机一般比较昂贵，没钱，所以没有经验~~\n\n#### 如何配置端口\n\n假设现在将服务器已经完整放到机子上，并且能正常运行了。\n\n在 server.properties 配置文件中查看 server-port 项，默认 25565，这是内网端口，现在需要将内网端口开放出去。\n\n开放端口有两种类型，一是对称开放，也就是内网端口和对应的外网端口相同；二是非对称开放，内网端口和对应的外网端口不同。\n\n服务商规定不一定相同，一般有下面几种情况\n\n1. 规定给某一部分端口开放\n\n   这种属于规定开放的对称端口，只需要将 server-port 值修改为规定端口，然后在游戏内使用 ip:端口的形式进入即可(也有可能是 域名:端口)\n\n   比如规定 30000 为开放端口，将 server-port 改为 30000，然后使用 ip:30000 作为服务器地址即可进入游戏\n\n2. 自由开放端口，但是开放的外网端口和内部端口不同\n\n   这种属于非对称开放端口，假设 server-port 设为 25565，外网端口生成为 30000，那么就使用 ip:30000 进入游戏\n\n3. 自由开放端口，开放的外网端口和内网端口相同\n\n   属于对称开放端口，和第一种情况相同，只是没用端口数量和端口号的限制\n\n### 如何进入服务器\n\n如果是在自己电脑上开服，自己只需要在服务器地址输入 `0.0.0.0` 即可，也可以是 `127.0.0.1:25565` 、`localhost:25565` 。注意，25565 改为实际内网端口，也就是 server-port 的值。\n\n如果已经放到云服务器上，按照 `ip:外网端口` 或者 `域名:外网端口` 的格式即可\n\n比如我的域名是 Torchman005.com，外网端口是 25565，那么服务器地址填写 `Torchman005.com:25565` 即可，如果是 ip 的话同理\n\nmod 服须知，尤其是 forge mod，要确保服务端 mod 和客户端 mod 列表相同。在 mcmod 页面可以看到 mod 安装要求，有的 mod 需要双端都装，有的只需要一端，有的只能一端。forge 要求很严格，客户端必须也是 forge 端。fabric 大部分为优化 mod，要求相对较松。\n\n正版问题，只需要更改 online-mode 项。如果使用了第三方皮肤站作为登录方式，那么需要设为 true 而不是 false。如果设为 false(离线登录)，那么 uuid 将会由本地分配而不是微软分配，再次更改为 true 时需要考虑玩家数据问题。因为这个问题不能进入服务器的玩家通常收到的提示时“无效的会话”\n\n---\n\n基础教程结束。通过以上教程，相信开一个简单的基友服不是问题了。\n\n---\n\n## 进阶教程\n\n锦上添花，选用外部优秀教程。~~我对教程帖挺挑剔的，所以用的都是我觉得不错的帖子~~\n\n### 如何使用自己的域名替代 ip:端口 的格式\n\n[Minecraft 联机中如何用域名替换 IP 和端口? - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv5920366/)\n\n### 如何为服务器添加 MCDR\n\n[快速上手 — MCDReforged 2.13.2 文档](https://docs.mcdreforged.com/zh-cn/latest/quick_start.html)\n\n### 如何实现与基岩版互通\n\n[我的世界间歇泉 Geyser 配置文件 config 注释版！ - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv31318719/)\n\n[Geyser 间歇泉实现 Minecraft 基岩版/JAVA 版互通服 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv8621880/)\n\n[Minecraft Geyser 互通服开服指南 | SakuraFrp 帮助文档 (natfrp.com)](https://doc.natfrp.com/offtopic/mc-geyser.html)\n\n### 如何使用面板控制服务器(使用 MCSM)\n\n[MCSManager——MC 服务器配置超全教程(Win) - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv20156621/)\n\n## 杂谈 EULA\n\n这里只讨论国际服，不讨论网易。\n\n从小学到现在(2024.10)，也算是 mc 腐竹圈的中年人了，也见证了国内 mc 服务器环境的变化。\n\n从最开始多玩盒子联机，到网易接手后联机难度大大降低，网易上各种服务器、联机房间兴起，再到越来越多人加入国际服，pcl、hmcl 独占一方。\n\n曾经 mcbbs 是众多服务器开发者、插件开发者、插件搬运工的聚集地，为国内提供了相当便利的资源站，也是国内很多腐竹的起点。2020 年左右算得上是国内腐竹涌现的时期，其中有良心腐竹，积极听取玩家建议，努力维护服务器，也有渣滓从 bbs 下个快餐服，圈钱跑路。\n\n良心维护也好，圈钱也好，都是个人想法，mojiang 的 eula 从来只是防君子不防小人。人家国外都一堆圈钱服，国内有什么理由不能有呢？双方自愿对吧。\n\n但是，双方自愿的前提是，双方，至少是玩家，对游戏还有足够的积极度。\n\nmc 是一款沙盒游戏，这款游戏是极度依赖社区创作的。如果 mojang 把 mod 全锁死，严格禁止光影材质包，严格禁止第三方服务器，那么这游戏已经离死不远了。\n\n而大多数玩家是没有创作能力的，真正的创作技术掌握在少数人手里，要想让少数人的技术满足大部分人的预期，那么创作者要有创作的动力，玩家要有提出意见的积极性。\n\n现在假设腐竹为 A，开发者为 B，服务器内有两个玩家 C 和 D，C 相对富裕，有赞助的能力。\n\nA 看好 B 的一个作品，花钱得到 B 作品的使用权，C 喜欢服务器的模式，在遵守 eula 的前提下为服务器赞助，D 没有赞助能力，但是他能够宣传给朋友们，带动更多人来玩服务器。\n\n这是一个很正常的发展模式，在这个过程中，A 有了玩家们的支持，愿意继续维护，B 有了 A 的投资，有了创作动力，C 和 D 在服务器也满足了自己的游戏体验，这是一个良性发展模式。\n\n而快餐服的存在，省去了 A 购买 B 使用权的过程，有的只是 A 无限收割玩家的热情。B 缺少了创作积极性，优秀作品逐渐减少。不过当然对 A 没有影响了，因为 A 已经不再购买 B。C 和 D 的热情没有得到正向反馈，热情减少，C 的赞助减少，D 的宣传作用减弱，A 收割的越来越少，直至没人愿意继续在他的服务器玩，于是 A 关掉服务器，不知从何处搞到另一个快餐服，继续以上模式。\n\n受影响的只有 B，C，D。这就是为什么快餐服会削减社区整体积极性。\n\n在 mcbbs 崩盘之后，直到现在，快餐服群体受了很大打击。为什么呢？因为没资源了，那些圈钱腐竹不懂技术，不会升级服务器版本，不会替换新版插件，不知道流行 mod 是什么。\n\n想象中是，快餐服倒闭后，大量玩家涌入良心服务器，良心服茁壮成长。\n\n可是曾经习惯快餐服的玩家，早就没了积极性，快餐服的快节奏也无法融入到良心服相对较慢的节奏。\n\n于是玩家整体规模开始下滑，市场开始缩减。良心腐竹们苦苦维持，全凭着一腔热血，但总有放弃的时候。\n\n以至于现在，出名服务器两只手可以数过来，一个服务器超过十个人常驻就谢天谢地了。\n\nmc 整体规模下降肯定还有别的原因，但我常混迹在腐竹圈，快餐服是我见到的最直接的原因。\n\n说白就是 eula 管的太松了，mojang 在当地都不怎么管，更何况山高皇帝远，mojang 几乎不可能管到中国来。\n\neula 不只是在开服时候强制要求你同意的一个文件，更应该作为每个腐竹的规范。如何运维好服务器？eula 已经给出答案了。下面是 eula 的部分原文。\n\n> 本 EULA 是您和我们（Mojang AB 和微软公司或（如适用）下文的“企业信息”一节列出的其当地关联公司之一）之间达成的法律协议。您应该阅读完整内容，但此处简要总结了一些要点以便为您提供指导，完整条款和条件仍然适用。\n>\n> - 本 Minecraft EULA 和[微软服务协议](https://www.microsoft.com/servicesagreement)共同适用于所有 Minecraft 服务。\n> - 您的内容为您所有，但请负责任和安全地分享它。\n> - 我们的社区标准帮助我们建立一个对所有人开放和安全的社区。\n> - 您可以开发工具、插件和服务，前提是它们看起来不是官方项目或者看起来未经过我们批准，例如不使用我们的徽标。\n> - 未经我们允许，请勿分发或将我们创建的任何内容用于商业用途。\n> - 我们会尽可能做到公开、诚实和相信他人，希望您对我们也是如此。\n\n> ## **您可以和不可以用 Minecraft 软件和内容做的事情**\n>\n> 您购买我们的游戏后，可以下载、安装和畅玩这些游戏。对于 Minecraft：Java 版的 服务器版本，您可以将其安装在服务器上并主持在线游戏。\n>\n> 但是，除非我们明确同意，否则您不得分发我们创建的任何内容。“分发我们创建的任何内容”是指：\n>\n> - 向任何其他人提供我们的游戏软件或内容；\n> - 将我们创建的任何内容用于商业用途；\n> - 试图通过我们创建的任何内容赚钱；或者\n> - 允许其他人以不公平或不合理的方式访问我们创建的任何内容。\n>\n> 因此，为清楚起见，“游戏”或“我们提供的内容”包括但不限于服务以及我们将来可能发布的任何其他游戏。它还包括游戏的更新、补丁、可下载内容、市场内容、加载项或修改版本、这些内容的一部分、商品、视听内容，或我们提供的任何其他内容。\n>\n> 除此之外，我们对您做的事情要求非常宽松，事实上我们鼓励您做一些很酷的事情，只是不要做我们规定不能做的那些事情即可。\n\n一句话来说，就是\n\n> **Minecraft 这个游戏是我们的，请不要利用我们的游戏来赚钱。**\n\n但是 eula 的存在并不为人所知，甚至很多人不知道这到底是什么东西。不像其他应用强制要求看完的用户协议，mc 的 eula 除了开服时候提示一下之外，从来没刻意强调过自己的存在。这也是有原因的，因为 mc 的 eula 针对的不是玩家群体，而是利用 mc 去赚钱的人。\n\n服务器是整个 mc 与资本关系最密切的地方，优秀资源在外可以自由分享，但是一旦到了服务器上就开始变味了。\n\n服务器运营需要成本，需要钱去租机子，需要时间去打磨。腐竹们需要维持运营就需要收入，收入可以是自己工作获得，也可以以公益赞助方式分摊到广大玩家，更可以是吸引氪金成为商业服。\n\n前两者是完全符合 eula 的，而第三者显然违反了 eula。就像上文所说，开设服务器必须要有资本的支撑才能够运行。而这样的“资本来源”对于基于 mc 开设的商业服务器来说，从何而来，是一大难题。\n\n但是 eula 并没有完全限制死商业服的发展\n\n仔细阅读 eula，并没有说“不允许使用 mc 进行任何盈利”，而是说“试图通过**我们创建的任何内容**赚钱”“允许其他人以**不公平或不合理的方式**访问**我们创建的任何内容**”。\n\n以 hypixel 为例，作为全球最大的小游戏服务器，hypixel 中氪金靠着 rank、gold、items 三大类，也就是特权、金币、道具。\n\nhypixel 无疑是商业服，但是为什么说他符合 eula 呢？这三大类为什么符合 eula？\n\n首先，所谓 `特权` ，在 hypixel 中仅仅是头衔称号、特效等徒有其表的加成，而 `道具` 也仅仅用做装饰用途，在实际游戏中，不管氪金多少，考验的都只是玩家的实力。而这些装饰特效，并不是 mojiang 创作的，是 hypixel 工作室自己编写的。所以无论从哪个角度看，hypixel 的商业模式在 eula 的规范下是相当成功的，名利双收。\n\n而快餐服的特点是，吸金，氪金和不氪金的体验差距巨大，甚至能花钱买 op。\n\n所以，eula 虽然没有实权，空有其表，但是确确实实规范了服务器与资本的关系，也确确实实指导腐竹们怎么进行服务器商业化的可持续化。\n\n综上，不要仅仅将 eula 视为不同意就不让自己开服的屑文件。\n\n在商业化时代，想赚钱但是遵守空有其表的 eula 好像确实是商业傻子，来钱肯定不如随心所欲的圈来的快。但不能否认的是，eula 的规范是商业服可持续化的必然之路，我们遵守 eula，也是对 mc 最基本的尊重。\n\n## 杂谈服务器经济体系\n\n玩了很多服务器，发现玩着玩着，人人大富翁，想要什么直接从服务器商店买，有新人进来先给他几十万带带他。\n\n很明显，遇到通货膨胀问题了。\n\n服务器货币一般有两种模式：\n\n1. 游戏矿物。比如钻石\n2. 系统商店，计分板货币\n\n首先看第一种，矿物作为货币。以钻石为例，确实是一个理想货币：不可再生，一般情况需要劳动才能获得。但是忽略了劳动难度。开荒时，钻石往往是很稀缺的资源，一个开荒玩家手里一下掏出几组钻石去交易是不可能的，除非没日没夜开矿透去挖。因此，昂贵矿物作为货币往往因为**产量过少**导致**市场缩减**。\n\n再看第二种，计分板货币，很常见的货币类型。下面是知乎某帖的回复。\n\n> 由于这个系统为每种劳动都人为定价了，必然会造成获取物品的价值之分（划算与否），导致的结果是所有人的玩法趋同，都向着挣钱最快的游戏方式努力，建设大量相同的设施，甚至养殖大量动物导致服务器卡顿。如果不调整兑换比例，在成为“土豪”后就会迅速对游戏厌倦，导致大量玩家流失，唯一的方式就是开始新周目所有财产清零，这也是很多服务器为什么生命周期如此之短的原因。\n\n总结两个方案。一边是缺钱，一边是钱太多。\n\n针对第一个问题，直接的方案是增大钻石刷新率，并在前期提高钻石的价格。但是当附近钻石都被开采完毕，新玩家只能到更远的地方发展。这一来割裂了玩家，二来新玩家体验很差。\n\n针对第二个问题，直接的方案是继续增大兑换比例，并减少玩家生产能力(比如添加体力系统)。但前一种治标不治本，后一种会引起玩家反感。所以，如果引入了计分板货币系统，通货膨胀是必然结局。\n\n结论就是，**mc 中任何经济体系都是没有用的**。\n\n(写文时候突发奇想一种解决方案，让所有玩家财产公有，但是每人每天有消费上限，共有财产定期收缴一部分。这种模式还是第一次想过)\n","tags":["Minecraft"],"categories":["Minecraft"]}]